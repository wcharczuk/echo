
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/blend/go-sdk/web/app.go (66.4%)</option>
				
				<option value="file1">github.com/blend/go-sdk/web/app_event.go (33.3%)</option>
				
				<option value="file2">github.com/blend/go-sdk/web/auth_manager.go (74.6%)</option>
				
				<option value="file3">github.com/blend/go-sdk/web/cached_static_file.go (0.0%)</option>
				
				<option value="file4">github.com/blend/go-sdk/web/cached_static_file_server.go (76.9%)</option>
				
				<option value="file5">github.com/blend/go-sdk/web/compressed_response_writer.go (80.0%)</option>
				
				<option value="file6">github.com/blend/go-sdk/web/config.go (77.6%)</option>
				
				<option value="file7">github.com/blend/go-sdk/web/constants.go (80.0%)</option>
				
				<option value="file8">github.com/blend/go-sdk/web/ctx.go (47.3%)</option>
				
				<option value="file9">github.com/blend/go-sdk/web/error.go (0.0%)</option>
				
				<option value="file10">github.com/blend/go-sdk/web/healthz.go (30.8%)</option>
				
				<option value="file11">github.com/blend/go-sdk/web/heathz_config.go (0.0%)</option>
				
				<option value="file12">github.com/blend/go-sdk/web/https_upgrader.go (15.3%)</option>
				
				<option value="file13">github.com/blend/go-sdk/web/https_upgrader_config.go (0.0%)</option>
				
				<option value="file14">github.com/blend/go-sdk/web/json_result.go (100.0%)</option>
				
				<option value="file15">github.com/blend/go-sdk/web/json_result_provider.go (18.2%)</option>
				
				<option value="file16">github.com/blend/go-sdk/web/middleware.go (26.7%)</option>
				
				<option value="file17">github.com/blend/go-sdk/web/mock_request_builder.go (65.6%)</option>
				
				<option value="file18">github.com/blend/go-sdk/web/mock_response_writer.go (71.4%)</option>
				
				<option value="file19">github.com/blend/go-sdk/web/no_content_result.go (0.0%)</option>
				
				<option value="file20">github.com/blend/go-sdk/web/no_content_result_provider.go (0.0%)</option>
				
				<option value="file21">github.com/blend/go-sdk/web/raw_response_writer.go (90.9%)</option>
				
				<option value="file22">github.com/blend/go-sdk/web/raw_result.go (100.0%)</option>
				
				<option value="file23">github.com/blend/go-sdk/web/redirect_result.go (0.0%)</option>
				
				<option value="file24">github.com/blend/go-sdk/web/rewrite_rule.go (100.0%)</option>
				
				<option value="file25">github.com/blend/go-sdk/web/route.go (33.3%)</option>
				
				<option value="file26">github.com/blend/go-sdk/web/route_parameters.go (25.0%)</option>
				
				<option value="file27">github.com/blend/go-sdk/web/session.go (68.4%)</option>
				
				<option value="file28">github.com/blend/go-sdk/web/session_cache.go (100.0%)</option>
				
				<option value="file29">github.com/blend/go-sdk/web/session_middleware.go (60.7%)</option>
				
				<option value="file30">github.com/blend/go-sdk/web/state.go (77.3%)</option>
				
				<option value="file31">github.com/blend/go-sdk/web/static_file_server.go (81.6%)</option>
				
				<option value="file32">github.com/blend/go-sdk/web/static_result.go (68.4%)</option>
				
				<option value="file33">github.com/blend/go-sdk/web/tcp_keep_alive_listener.go (100.0%)</option>
				
				<option value="file34">github.com/blend/go-sdk/web/text_result_provider.go (41.7%)</option>
				
				<option value="file35">github.com/blend/go-sdk/web/tls_config.go (56.7%)</option>
				
				<option value="file36">github.com/blend/go-sdk/web/tree.go (85.8%)</option>
				
				<option value="file37">github.com/blend/go-sdk/web/util.go (63.5%)</option>
				
				<option value="file38">github.com/blend/go-sdk/web/view_cache.go (42.6%)</option>
				
				<option value="file39">github.com/blend/go-sdk/web/view_cache_config.go (100.0%)</option>
				
				<option value="file40">github.com/blend/go-sdk/web/view_model.go (0.0%)</option>
				
				<option value="file41">github.com/blend/go-sdk/web/view_result.go (70.6%)</option>
				
				<option value="file42">github.com/blend/go-sdk/web/view_result_provider.go (72.1%)</option>
				
				<option value="file43">github.com/blend/go-sdk/web/xml_result.go (0.0%)</option>
				
				<option value="file44">github.com/blend/go-sdk/web/xml_result_provider.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package web

import (
        "context"
        "crypto/tls"
        "crypto/x509"
        "fmt"
        "io/ioutil"
        "net"
        "net/http"
        "strings"
        "sync/atomic"
        "time"

        "net/url"

        "github.com/blend/go-sdk/env"
        "github.com/blend/go-sdk/exception"
        "github.com/blend/go-sdk/logger"
)

// New returns a new app.
func New() *App <span class="cov8" title="1">{
        views := NewViewCache()
        vrp := &amp;ViewResultProvider{views: views}

        return &amp;App{
                auth:                  NewAuthManager(),
                state:                 map[string]interface{}{},
                statics:               map[string]Fileserver{},
                readTimeout:           DefaultReadTimeout,
                redirectTrailingSlash: true,
                recoverPanics:         true,
                defaultHeaders:        DefaultHeaders,
                views:                 views,
                viewProvider:          vrp,
                jsonProvider:          &amp;JSONResultProvider{},
                xmlProvider:           &amp;XMLResultProvider{},
                textProvider:          &amp;TextResultProvider{},
                started:               make(chan struct{}),
        }
}</span>

// NewFromEnv returns a new app from the environment.
func NewFromEnv() *App <span class="cov8" title="1">{
        return NewFromConfig(NewConfigFromEnv())
}</span>

// NewFromConfig returns a new app from a given config.
func NewFromConfig(cfg *Config) *App <span class="cov8" title="1">{
        return New().WithConfig(cfg)
}</span>

// App is the server for the app.
type App struct {
        cfg *Config

        log   *logger.Logger
        auth  *AuthManager
        views *ViewCache

        baseURL  *url.URL
        bindAddr string

        hsts                  bool
        hstsMaxAgeSeconds     int
        hstsIncludeSubdomains bool
        hstsPreload           bool

        tlsConfig *tls.Config

        defaultHeaders map[string]string

        didRunStartupTasks bool
        onStartDelegate    AppStartDelegate

        started chan struct{}
        running int32

        server   *http.Server
        listener *net.TCPListener

        // statics serve files at various routes
        statics map[string]Fileserver

        routes                  map[string]*node
        notFoundHandler         Handler
        methodNotAllowedHandler Handler
        panicAction             PanicAction
        redirectTrailingSlash   bool
        handleOptions           bool
        handleMethodNotAllowed  bool

        defaultMiddleware []Middleware

        defaultResultProvider ResultProvider
        viewProvider          *ViewResultProvider
        jsonProvider          *JSONResultProvider
        xmlProvider           *XMLResultProvider
        textProvider          *TextResultProvider

        maxHeaderBytes    int
        readTimeout       time.Duration
        readHeaderTimeout time.Duration
        writeTimeout      time.Duration
        idleTimeout       time.Duration

        state map[string]interface{}

        recoverPanics bool
}

// WithConfig sets the config and applies the config's setting.
func (a *App) WithConfig(cfg *Config) *App <span class="cov8" title="1">{
        a.cfg = cfg

        a.WithBindAddr(cfg.GetBindAddr())
        a.WithRedirectTrailingSlash(cfg.GetRedirectTrailingSlash())
        a.WithHandleMethodNotAllowed(cfg.GetHandleMethodNotAllowed())
        a.WithHandleOptions(cfg.GetHandleOptions())
        a.WithRecoverPanics(cfg.GetRecoverPanics())
        a.WithDefaultHeaders(cfg.GetDefaultHeaders(DefaultHeaders))
        a.WithHSTS(cfg.GetHSTS())
        a.WithHSTSMaxAgeSeconds(cfg.GetHSTSMaxAgeSeconds())
        a.WithHSTSIncludeSubdomains(cfg.GetHSTSIncludeSubDomains())
        a.WithHSTSPreload(cfg.GetHSTSPreload())

        a.WithMaxHeaderBytes(cfg.GetMaxHeaderBytes())
        a.WithReadHeaderTimeout(cfg.GetReadHeaderTimeout())
        a.WithReadTimeout(cfg.GetReadTimeout())
        a.WithWriteTimeout(cfg.GetWriteTimeout())
        a.WithIdleTimeout(cfg.GetIdleTimeout())

        a.WithAuth(NewAuthManagerFromConfig(cfg))
        a.WithViews(NewViewCacheFromConfig(&amp;cfg.Views))
        a.WithViewResultProvider(&amp;ViewResultProvider{views: a.Views()})
        a.WithBaseURL(MustParseURL(cfg.GetBaseURL()))

        return a
}</span>

// Running returns if the app is running.
func (a *App) Running() (running bool) <span class="cov8" title="1">{
        return atomic.LoadInt32(&amp;a.running) == 1
}</span>

// WithDefaultHeaders sets the default headers
func (a *App) WithDefaultHeaders(headers map[string]string) *App <span class="cov8" title="1">{
        a.defaultHeaders = headers
        return a
}</span>

// WithDefaultHeader adds a default header.
func (a *App) WithDefaultHeader(key string, value string) *App <span class="cov8" title="1">{
        a.defaultHeaders[key] = value
        return a
}</span>

// DefaultHeaders returns the default headers.
func (a *App) DefaultHeaders() map[string]string <span class="cov8" title="1">{
        return a.defaultHeaders
}</span>

// WithState sets app state and returns a reference to the app for building apps with a fluent api.
func (a *App) WithState(key string, value interface{}) *App <span class="cov0" title="0">{
        a.state[key] = value
        return a
}</span>

// GetState gets app state element by key.
func (a *App) GetState(key string) interface{} <span class="cov0" title="0">{
        if value, hasValue := a.state[key]; hasValue </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// SetState sets app state.
func (a *App) SetState(key string, value interface{}) <span class="cov0" title="0">{
        a.state[key] = value
}</span>

// State is a bag for common app state.
func (a *App) State() State <span class="cov0" title="0">{
        return a.state
}</span>

// RedirectTrailingSlash returns if we should redirect missing trailing slashes to the correct route.
func (a *App) RedirectTrailingSlash() bool <span class="cov0" title="0">{
        return a.redirectTrailingSlash
}</span>

// WithRedirectTrailingSlash sets if we should redirect missing trailing slashes.
func (a *App) WithRedirectTrailingSlash(value bool) *App <span class="cov8" title="1">{
        a.redirectTrailingSlash = value
        return a
}</span>

// HandleMethodNotAllowed returns if we should handle unhandled verbs.
func (a *App) HandleMethodNotAllowed() bool <span class="cov8" title="1">{
        return a.handleMethodNotAllowed
}</span>

// WithHandleMethodNotAllowed sets if we should handlem ethod not allowed.
func (a *App) WithHandleMethodNotAllowed(handle bool) *App <span class="cov8" title="1">{
        a.handleMethodNotAllowed = handle
        return a
}</span>

// HandleOptions returns if we should handle OPTIONS requests.
func (a *App) HandleOptions() bool <span class="cov8" title="1">{
        return a.handleOptions
}</span>

// WithHandleOptions returns if we should handle OPTIONS requests.
func (a *App) WithHandleOptions(handle bool) *App <span class="cov8" title="1">{
        a.handleOptions = handle
        return a
}</span>

// RecoverPanics returns if the app recovers panics.
func (a *App) RecoverPanics() bool <span class="cov8" title="1">{
        return a.recoverPanics
}</span>

// WithRecoverPanics sets if the app should recover panics.
func (a *App) WithRecoverPanics(value bool) *App <span class="cov8" title="1">{
        a.recoverPanics = value
        return a
}</span>

// BaseURL returns the domain for the app.
func (a *App) BaseURL() *url.URL <span class="cov0" title="0">{
        return a.baseURL
}</span>

// WithBaseURL sets the `BaseURL` field and returns a reference to the app for building apps with a fluent api.
func (a *App) WithBaseURL(baseURL *url.URL) *App <span class="cov8" title="1">{
        a.SetBaseURL(baseURL)
        return a
}</span>

// SetBaseURL sets the base url for the app.
func (a *App) SetBaseURL(baseURL *url.URL) <span class="cov8" title="1">{
        a.baseURL = baseURL
}</span>

// SetParsedBaseURL sets the BaseURL from a string.
func (a *App) SetParsedBaseURL(baseURL string) error <span class="cov0" title="0">{
        u, err := url.Parse(baseURL)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">a.baseURL = u
        return nil</span>
}

// MaxHeaderBytes returns the app max header bytes.
func (a *App) MaxHeaderBytes() int <span class="cov8" title="1">{
        return a.maxHeaderBytes
}</span>

// WithMaxHeaderBytes sets the max header bytes value and returns a reference.
func (a *App) WithMaxHeaderBytes(byteCount int) *App <span class="cov8" title="1">{
        a.maxHeaderBytes = byteCount
        return a
}</span>

// ReadHeaderTimeout returns the read header timeout for the server.
func (a *App) ReadHeaderTimeout() time.Duration <span class="cov8" title="1">{
        return a.readHeaderTimeout
}</span>

// WithReadHeaderTimeout returns the read header timeout for the server.
func (a *App) WithReadHeaderTimeout(timeout time.Duration) *App <span class="cov8" title="1">{
        a.readHeaderTimeout = timeout
        return a
}</span>

// ReadTimeout returns the read timeout for the server.
func (a *App) ReadTimeout() time.Duration <span class="cov8" title="1">{
        return a.readTimeout
}</span>

// WithReadTimeout sets the read timeout for the server and returns a reference to the app for building apps with a fluent api.
func (a *App) WithReadTimeout(timeout time.Duration) *App <span class="cov8" title="1">{
        a.readTimeout = timeout
        return a
}</span>

// IdleTimeout is the time before we close a connection.
func (a *App) IdleTimeout() time.Duration <span class="cov8" title="1">{
        return a.idleTimeout
}</span>

// WithIdleTimeout sets the idle timeout.
func (a *App) WithIdleTimeout(timeout time.Duration) *App <span class="cov8" title="1">{
        a.idleTimeout = timeout
        return a
}</span>

// WriteTimeout returns the write timeout for the server.
func (a *App) WriteTimeout() time.Duration <span class="cov8" title="1">{
        return a.writeTimeout
}</span>

// WithWriteTimeout sets the write timeout for the server and returns a reference to the app for building apps with a fluent api.
func (a *App) WithWriteTimeout(timeout time.Duration) *App <span class="cov8" title="1">{
        a.writeTimeout = timeout
        return a
}</span>

// WithHSTS enables or disables issuing the strict transport security header.
func (a *App) WithHSTS(enabled bool) *App <span class="cov8" title="1">{
        a.hsts = enabled
        return a
}</span>

// HSTS returns if strict transport security is enabled.
func (a *App) HSTS() bool <span class="cov8" title="1">{
        return a.hsts
}</span>

// WithHSTSMaxAgeSeconds sets the hsts max age seconds.
func (a *App) WithHSTSMaxAgeSeconds(ageSeconds int) *App <span class="cov8" title="1">{
        a.hstsMaxAgeSeconds = ageSeconds
        return a
}</span>

// HSTSMaxAgeSeconds is the maximum lifetime browsers should honor the secure transport header.
func (a *App) HSTSMaxAgeSeconds() int <span class="cov8" title="1">{
        return a.hstsMaxAgeSeconds
}</span>

// WithHSTSIncludeSubdomains sets if we should include subdomains in hsts.
func (a *App) WithHSTSIncludeSubdomains(includeSubdomains bool) *App <span class="cov8" title="1">{
        a.hstsIncludeSubdomains = includeSubdomains
        return a
}</span>

// HSTSIncludeSubdomains returns if we should include subdomains in hsts.
func (a *App) HSTSIncludeSubdomains() bool <span class="cov8" title="1">{
        return a.hstsIncludeSubdomains
}</span>

// WithHSTSPreload sets if we preload hsts.
func (a *App) WithHSTSPreload(preload bool) *App <span class="cov8" title="1">{
        a.hstsPreload = preload
        return a
}</span>

// HSTSPreload returns if we should preload hsts.
func (a *App) HSTSPreload() bool <span class="cov8" title="1">{
        return a.hstsPreload
}</span>

// WithTLSConfig sets the tls config for the app.
func (a *App) WithTLSConfig(config *tls.Config) *App <span class="cov0" title="0">{
        a.SetTLSConfig(config)
        return a
}</span>

// SetTLSConfig sets the tls config.
func (a *App) SetTLSConfig(config *tls.Config) <span class="cov0" title="0">{
        a.tlsConfig = config
}</span>

// TLSConfig returns the app tls config.
func (a *App) TLSConfig() *tls.Config <span class="cov8" title="1">{
        return a.tlsConfig
}</span>

// SetTLSCertPair sets the app to use TLS with a given cert.
func (a *App) SetTLSCertPair(tlsCert, tlsKey []byte) error <span class="cov8" title="1">{
        cert, err := tls.X509KeyPair(tlsCert, tlsKey)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if a.tlsConfig == nil </span><span class="cov8" title="1">{
                a.tlsConfig = &amp;tls.Config{
                        Certificates: []tls.Certificate{cert},
                }
        }</span> else<span class="cov8" title="1"> {
                a.tlsConfig.Certificates = []tls.Certificate{cert}
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// SetTLSCertPairFromFiles reads a tls key pair from a given set of paths.
func (a *App) SetTLSCertPairFromFiles(tlsCertPath, tlsKeyPath string) error <span class="cov0" title="0">{
        cert, err := ioutil.ReadFile(tlsCertPath)
        if err != nil </span><span class="cov0" title="0">{
                return exception.Wrap(err)
        }</span>

        <span class="cov0" title="0">key, err := ioutil.ReadFile(tlsKeyPath)
        if err != nil </span><span class="cov0" title="0">{
                return exception.Wrap(err)
        }</span>

        <span class="cov0" title="0">return a.SetTLSCertPair(cert, key)</span>
}

// SetTLSFromEnv reads TLS settings from the environment.
func (a *App) SetTLSFromEnv() error <span class="cov0" title="0">{
        tlsCert := env.Env().Bytes(EnvironmentVariableTLSCert)
        tlsKey := env.Env().Bytes(EnvironmentVariableTLSKey)
        tlsCertPath := env.Env().String(EnvironmentVariableTLSCertFile)
        tlsKeyPath := env.Env().String(EnvironmentVariableTLSKeyFile)

        if len(tlsCert) &gt; 0 &amp;&amp; len(tlsKey) &gt; 0 </span><span class="cov0" title="0">{
                return a.SetTLSCertPair(tlsCert, tlsKey)
        }</span> else<span class="cov0" title="0"> if len(tlsCertPath) &gt; 0 &amp;&amp; len(tlsKeyPath) &gt; 0 </span><span class="cov0" title="0">{
                return a.SetTLSCertPairFromFiles(tlsCertPath, tlsKeyPath)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// SetTLSClientCertPool set the client cert pool from a given set of pems.
func (a *App) SetTLSClientCertPool(certs ...[]byte) error <span class="cov8" title="1">{
        if a.tlsConfig == nil </span><span class="cov8" title="1">{
                a.tlsConfig = &amp;tls.Config{}
        }</span>
        <span class="cov8" title="1">a.tlsConfig.ClientCAs = x509.NewCertPool()
        for _, cert := range certs </span><span class="cov8" title="1">{
                ok := a.tlsConfig.ClientCAs.AppendCertsFromPEM(cert)
                if !ok </span><span class="cov8" title="1">{
                        return exception.New("invalid ca cert for client cert pool")
                }</span>
        }
        <span class="cov8" title="1">a.tlsConfig.BuildNameToCertificate()

        // this forces the server to reload the tls config for every request if there is a cert pool loaded.
        // normally this would introduce overhead but it allows us to hot patch the cert pool.
        a.tlsConfig.GetConfigForClient = func(_ *tls.ClientHelloInfo) (*tls.Config, error) </span><span class="cov0" title="0">{
                return a.tlsConfig, nil
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// WithTLSClientCertVerification sets the verification level for client certs.
func (a *App) WithTLSClientCertVerification(verification tls.ClientAuthType) *App <span class="cov8" title="1">{
        if a.tlsConfig == nil </span><span class="cov8" title="1">{
                a.tlsConfig = &amp;tls.Config{}
        }</span>
        <span class="cov8" title="1">a.tlsConfig.ClientAuth = verification
        return a</span>
}

// WithPort sets the port for the bind address of the app, and returns a reference to the app.
func (a *App) WithPort(port int32) *App <span class="cov8" title="1">{
        a.SetPort(port)
        return a
}</span>

// SetPort sets the port the app listens on, typically to `:%d` which indicates listen on any interface.
func (a *App) SetPort(port int32) <span class="cov8" title="1">{
        a.bindAddr = fmt.Sprintf(":%v", port)
}</span>

// WithPortFromEnv sets the port from an environment variable, and returns a reference to the app.
func (a *App) WithPortFromEnv() *App <span class="cov8" title="1">{
        a.SetPortFromEnv()
        return a
}</span>

// SetPortFromEnv sets the port from an environment variable, and returns a reference to the app.
func (a *App) SetPortFromEnv() error <span class="cov8" title="1">{
        if env.Env().Has(EnvironmentVariablePort) </span><span class="cov8" title="1">{
                port, err := env.Env().Int32(EnvironmentVariablePort)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">a.bindAddr = fmt.Sprintf(":%v", port)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// BindAddr returns the address the server will bind to.
func (a *App) BindAddr() string <span class="cov8" title="1">{
        return a.bindAddr
}</span>

// WithBindAddr sets the address the app listens on, and returns a reference to the app.
func (a *App) WithBindAddr(bindAddr string) *App <span class="cov8" title="1">{
        a.bindAddr = bindAddr
        return a
}</span>

// WithBindAddrFromEnv sets the address the app listens on, and returns a reference to the app.
func (a *App) WithBindAddrFromEnv() *App <span class="cov8" title="1">{
        a.bindAddr = env.Env().String(EnvironmentVariableBindAddr)
        return a
}</span>

// Logger returns the diagnostics agent for the app.
func (a *App) Logger() *logger.Logger <span class="cov8" title="1">{
        return a.log
}</span>

// WithLogger sets the app logger agent and returns a reference to the app.
// It also sets underlying loggers in any child resources like providers and the auth manager.
func (a *App) WithLogger(log *logger.Logger) *App <span class="cov8" title="1">{
        a.log = log
        if a.viewProvider != nil </span><span class="cov8" title="1">{
                a.viewProvider.log = log
        }</span>
        <span class="cov8" title="1">if a.jsonProvider != nil </span><span class="cov8" title="1">{
                a.jsonProvider.log = log
        }</span>
        <span class="cov8" title="1">if a.xmlProvider != nil </span><span class="cov8" title="1">{
                a.xmlProvider.log = log
        }</span>
        <span class="cov8" title="1">if a.textProvider != nil </span><span class="cov8" title="1">{
                a.textProvider.log = log
        }</span>
        <span class="cov8" title="1">if a.auth != nil </span><span class="cov8" title="1">{
                a.auth.log = log
        }</span>
        <span class="cov8" title="1">return a</span>
}

// WithDefaultMiddleware sets the application wide default middleware.
func (a *App) WithDefaultMiddleware(middleware ...Middleware) *App <span class="cov8" title="1">{
        a.defaultMiddleware = middleware
        return a
}</span>

// DefaultMiddleware returns the default middleware.
func (a *App) DefaultMiddleware() []Middleware <span class="cov8" title="1">{
        return a.defaultMiddleware
}</span>

// OnStart lets you register a task that is run before the server starts.
// Typically this delegate sets up the database connection and other init items.
func (a *App) OnStart(action AppStartDelegate) <span class="cov0" title="0">{
        a.onStartDelegate = action
}</span>

// CreateServer returns the basic http.Server for the app.
func (a *App) CreateServer() *http.Server <span class="cov8" title="1">{
        return &amp;http.Server{
                Addr:              a.BindAddr(),
                Handler:           a,
                MaxHeaderBytes:    a.maxHeaderBytes,
                ReadTimeout:       a.readTimeout,
                ReadHeaderTimeout: a.readHeaderTimeout,
                WriteTimeout:      a.writeTimeout,
                IdleTimeout:       a.idleTimeout,
                TLSConfig:         a.tlsConfig,
        }
}</span>

// WithServer sets the server.
func (a *App) WithServer(server *http.Server) *App <span class="cov0" title="0">{
        a.server = server
        return a
}</span>

// Server returns the underyling http server.
func (a *App) Server() *http.Server <span class="cov0" title="0">{
        return a.server
}</span>

// Listener returns the underlying listener.
func (a *App) Listener() *net.TCPListener <span class="cov8" title="1">{
        return a.listener
}</span>

// Start starts the server and binds to the given address.
func (a *App) Start() (err error) <span class="cov8" title="1">{
        start := time.Now()
        if a.log != nil </span><span class="cov8" title="1">{
                a.log.SyncTrigger(NewAppEvent(AppStart).WithApp(a))
                defer a.log.SyncTrigger(NewAppEvent(AppExit).WithApp(a).WithErr(err))
        }</span>

        <span class="cov8" title="1">if a.tlsConfig == nil &amp;&amp; a.cfg != nil </span><span class="cov8" title="1">{
                a.tlsConfig, err = a.cfg.TLS.GetConfig()
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        <span class="cov8" title="1">if a.server == nil </span><span class="cov8" title="1">{
                a.server = a.CreateServer()
        }</span>

        // run the provided startup delegate.
        <span class="cov8" title="1">if a.onStartDelegate != nil </span><span class="cov0" title="0">{
                err = a.onStartDelegate(a)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        // initialize the view cache.
        <span class="cov8" title="1">err = a.StartupTasks()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">serverProtocol := "http"
        if a.server.TLSConfig != nil </span><span class="cov0" title="0">{
                serverProtocol = "https (tls)"
        }</span>

        <span class="cov8" title="1">a.syncInfof("%s server started, listening on %s", serverProtocol, a.bindAddr)
        if a.log != nil </span><span class="cov8" title="1">{
                if a.log.Flags() != nil </span><span class="cov8" title="1">{
                        a.syncInfof("%s server logging flags %s", serverProtocol, a.log.Flags().String())
                }</span>
        }

        <span class="cov8" title="1">if a.server.TLSConfig != nil &amp;&amp; a.server.TLSConfig.ClientCAs != nil </span><span class="cov0" title="0">{
                a.syncInfof("%s using client cert pool with (%d) client certs", serverProtocol, len(a.server.TLSConfig.ClientCAs.Subjects()))
        }</span>

        <span class="cov8" title="1">var listener net.Listener
        listener, err = net.Listen("tcp", a.bindAddr)
        if err != nil </span><span class="cov0" title="0">{
                err = exception.Wrap(err)
                return
        }</span>
        <span class="cov8" title="1">a.listener = listener.(*net.TCPListener)

        if a.log != nil </span><span class="cov8" title="1">{
                a.log.SyncTrigger(NewAppEvent(AppStartComplete).WithApp(a).WithElapsed(time.Since(start)))
        }</span>

        <span class="cov8" title="1">a.setRunning()
        keepAlive := TCPKeepAliveListener{a.listener}
        if a.server.TLSConfig != nil </span><span class="cov0" title="0">{
                err = exception.Wrap(a.server.ServeTLS(keepAlive, "", ""))
        }</span> else<span class="cov8" title="1"> {
                err = exception.Wrap(a.server.Serve(keepAlive))
        }</span>
        <span class="cov8" title="1">a.setStopped()
        return</span>
}

// Started returns a channel signalling the app has started.
func (a *App) Started() &lt;-chan struct{} <span class="cov8" title="1">{
        return a.started
}</span>

// Shutdown stops the server.
func (a *App) Shutdown() error <span class="cov8" title="1">{
        if !a.Running() </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        serverProtocol := "http"
        if a.server.TLSConfig != nil </span><span class="cov8" title="1">{
                serverProtocol = "https (tls)"
        }</span>

        <span class="cov8" title="1">a.syncInfof("%s server shutting down", serverProtocol)
        a.server.SetKeepAlivesEnabled(false)
        return exception.Wrap(a.server.Shutdown(ctx))</span>
}

// WithControllers registers given controllers and returns a reference to the app.
func (a *App) WithControllers(controllers ...Controller) *App <span class="cov0" title="0">{
        for _, c := range controllers </span><span class="cov0" title="0">{
                a.Register(c)
        }</span>
        <span class="cov0" title="0">return a</span>
}

// Register registers a controller with the app's router.
func (a *App) Register(c Controller) <span class="cov0" title="0">{
        c.Register(a)
}</span>

// --------------------------------------------------------------------------------
// Result Providers
// --------------------------------------------------------------------------------

// WithViewResultProvider sets the view result provider.
func (a *App) WithViewResultProvider(vrp *ViewResultProvider) *App <span class="cov8" title="1">{
        a.viewProvider = vrp
        return a
}</span>

// ViewResultProvider returns the view result provider.
func (a *App) ViewResultProvider() *ViewResultProvider <span class="cov0" title="0">{
        return a.viewProvider
}</span>

// WithJSONResultProvider sets the json result provider.
func (a *App) WithJSONResultProvider(jrp *JSONResultProvider) *App <span class="cov0" title="0">{
        a.jsonProvider = jrp
        return a
}</span>

// JSONResultProvider returns the json result provider.
func (a *App) JSONResultProvider() *JSONResultProvider <span class="cov0" title="0">{
        return a.jsonProvider
}</span>

// WithXMLResultProvider sets the xml result provider.
func (a *App) WithXMLResultProvider(xrp *XMLResultProvider) *App <span class="cov0" title="0">{
        a.xmlProvider = xrp
        return a
}</span>

// XMLResultProvider returns the xml result provider.
func (a *App) XMLResultProvider() *XMLResultProvider <span class="cov0" title="0">{
        return a.xmlProvider
}</span>

// WithTextResultProvider sets the text result provider.
func (a *App) WithTextResultProvider(trp *TextResultProvider) *App <span class="cov0" title="0">{
        a.textProvider = trp
        return a
}</span>

// TextResultProvider returns the text result provider.
func (a *App) TextResultProvider() *TextResultProvider <span class="cov0" title="0">{
        return a.textProvider
}</span>

// WithDefaultResultProvider sets the default result provider.
func (a *App) WithDefaultResultProvider(drp ResultProvider) *App <span class="cov0" title="0">{
        a.defaultResultProvider = drp
        return a
}</span>

// DefaultResultProvider returns the app wide default result provider.
func (a *App) DefaultResultProvider() ResultProvider <span class="cov0" title="0">{
        return a.defaultResultProvider
}</span>

// --------------------------------------------------------------------------------
// Auth Manager
// --------------------------------------------------------------------------------

// WithAuth sets the auth manager.
func (a *App) WithAuth(am *AuthManager) *App <span class="cov8" title="1">{
        a.auth = am
        return a
}</span>

// Auth returns the session manager.
func (a *App) Auth() *AuthManager <span class="cov8" title="1">{
        return a.auth
}</span>

// --------------------------------------------------------------------------------
// Views
// --------------------------------------------------------------------------------

// WithViews sets the view cache.
func (a *App) WithViews(vc *ViewCache) *App <span class="cov8" title="1">{
        a.views = vc
        return a
}</span>

// Views returns the view cache.
func (a *App) Views() *ViewCache <span class="cov8" title="1">{
        return a.views
}</span>

// --------------------------------------------------------------------------------
// Static Result Methods
// --------------------------------------------------------------------------------

// SetStaticRewriteRule adds a rewrite rule for a specific statically served path.
// It mutates the path for the incoming static file request to the fileserver according to the action.
func (a *App) SetStaticRewriteRule(route, match string, action RewriteAction) error <span class="cov8" title="1">{
        mountedRoute := a.createStaticMountRoute(route)
        if static, hasRoute := a.statics[mountedRoute]; hasRoute </span><span class="cov8" title="1">{
                return static.AddRewriteRule(match, action)
        }</span>
        <span class="cov0" title="0">return exception.Newf("no static fileserver mounted at route").WithMessagef("route: %s", route)</span>
}

// SetStaticHeader adds a header for the given static path.
// These headers are automatically added to any result that the static path fileserver sends.
func (a *App) SetStaticHeader(route, key, value string) error <span class="cov8" title="1">{
        mountedRoute := a.createStaticMountRoute(route)
        if static, hasRoute := a.statics[mountedRoute]; hasRoute </span><span class="cov8" title="1">{
                static.AddHeader(key, value)
                return nil
        }</span>
        <span class="cov0" title="0">return exception.Newf("no static fileserver mounted at route").WithMessagef("route: %s", mountedRoute)</span>
}

// SetStaticMiddleware adds static middleware for a given route.
func (a *App) SetStaticMiddleware(route string, middlewares ...Middleware) error <span class="cov0" title="0">{
        mountedRoute := a.createStaticMountRoute(route)
        if static, hasRoute := a.statics[mountedRoute]; hasRoute </span><span class="cov0" title="0">{
                static.SetMiddleware(middlewares...)
                return nil
        }</span>
        <span class="cov0" title="0">return exception.Newf("no static fileserver mounted at route").WithMessagef("route: %s", mountedRoute)</span>
}

// ServeStatic serves files from the given file system root.
// If the path does not end with "/*filepath" that suffix will be added for you internally.
// For example if root is "/etc" and *filepath is "passwd", the local file
// "/etc/passwd" would be served.
func (a *App) ServeStatic(route, filepath string) <span class="cov8" title="1">{
        sfs := NewStaticFileServer(http.Dir(filepath))
        mountedRoute := a.createStaticMountRoute(route)
        a.statics[mountedRoute] = sfs
        a.Handle("GET", mountedRoute, a.renderAction(a.middlewarePipeline(sfs.Action)))
}</span>

// ServeStaticCached serves files from the given file system root.
// If the path does not end with "/*filepath" that suffix will be added for you internally.
func (a *App) ServeStaticCached(route, filepath string) <span class="cov0" title="0">{
        sfs := NewCachedStaticFileServer(http.Dir(filepath))
        mountedRoute := a.createStaticMountRoute(route)
        a.statics[mountedRoute] = sfs
        a.Handle("GET", mountedRoute, a.renderAction(a.middlewarePipeline(sfs.Action)))
}</span>

func (a *App) createStaticMountRoute(route string) string <span class="cov8" title="1">{
        mountedRoute := route
        if !strings.HasSuffix(mountedRoute, "*"+RouteTokenFilepath) </span><span class="cov8" title="1">{
                if strings.HasSuffix(mountedRoute, "/") </span><span class="cov8" title="1">{
                        mountedRoute = mountedRoute + "*" + RouteTokenFilepath
                }</span> else<span class="cov8" title="1"> {
                        mountedRoute = mountedRoute + "/*" + RouteTokenFilepath
                }</span>
        }
        <span class="cov8" title="1">return mountedRoute</span>
}

// --------------------------------------------------------------------------------
// Router internal methods
// --------------------------------------------------------------------------------

// WithNotFoundHandler sets the not found handler.
func (a *App) WithNotFoundHandler(handler Action) *App <span class="cov8" title="1">{
        a.notFoundHandler = a.renderAction(handler)
        return a
}</span>

// WithMethodNotAllowedHandler sets the not allowed handler.
func (a *App) WithMethodNotAllowedHandler(handler Action) *App <span class="cov0" title="0">{
        a.methodNotAllowedHandler = a.renderAction(handler)
        return a
}</span>

// WithPanicAction sets the panic action.
func (a *App) WithPanicAction(action PanicAction) *App <span class="cov8" title="1">{
        a.panicAction = action
        return a
}</span>

// --------------------------------------------------------------------------------
// Testing Methods
// --------------------------------------------------------------------------------

// Mock returns a request bulider to facilitate mocking requests.
func (a *App) Mock() *MockRequestBuilder <span class="cov8" title="1">{
        return NewMockRequestBuilder(a)
}</span>

// --------------------------------------------------------------------------------
// Route Registration / HTTP Methods
// --------------------------------------------------------------------------------

// GET registers a GET request handler.
func (a *App) GET(path string, action Action, middleware ...Middleware) <span class="cov8" title="1">{
        a.Handle("GET", path, a.renderAction(a.middlewarePipeline(action, middleware...)))
}</span>

// OPTIONS registers a OPTIONS request handler.
func (a *App) OPTIONS(path string, action Action, middleware ...Middleware) <span class="cov0" title="0">{
        a.Handle("OPTIONS", path, a.renderAction(a.middlewarePipeline(action, middleware...)))
}</span>

// HEAD registers a HEAD request handler.
func (a *App) HEAD(path string, action Action, middleware ...Middleware) <span class="cov0" title="0">{
        a.Handle("HEAD", path, a.renderAction(a.middlewarePipeline(action, middleware...)))
}</span>

// PUT registers a PUT request handler.
func (a *App) PUT(path string, action Action, middleware ...Middleware) <span class="cov0" title="0">{
        a.Handle("PUT", path, a.renderAction(a.middlewarePipeline(action, middleware...)))
}</span>

// PATCH registers a PATCH request handler.
func (a *App) PATCH(path string, action Action, middleware ...Middleware) <span class="cov0" title="0">{
        a.Handle("PATCH", path, a.renderAction(a.middlewarePipeline(action, middleware...)))
}</span>

// POST registers a POST request actions.
func (a *App) POST(path string, action Action, middleware ...Middleware) <span class="cov0" title="0">{
        a.Handle("POST", path, a.renderAction(a.middlewarePipeline(action, middleware...)))
}</span>

// DELETE registers a DELETE request handler.
func (a *App) DELETE(path string, action Action, middleware ...Middleware) <span class="cov0" title="0">{
        a.Handle("DELETE", path, a.renderAction(a.middlewarePipeline(action, middleware...)))
}</span>

// Handle adds a raw handler at a given method and path.
func (a *App) Handle(method, path string, handler Handler) <span class="cov8" title="1">{
        if len(path) == 0 </span><span class="cov0" title="0">{
                panic("path must not be empty")</span>
        }
        <span class="cov8" title="1">if path[0] != '/' </span><span class="cov0" title="0">{
                panic("path must begin with '/' in path '" + path + "'")</span>
        }
        <span class="cov8" title="1">if a.routes == nil </span><span class="cov8" title="1">{
                a.routes = make(map[string]*node)
        }</span>

        <span class="cov8" title="1">root := a.routes[method]
        if root == nil </span><span class="cov8" title="1">{
                root = new(node)
                a.routes[method] = root
        }</span>

        <span class="cov8" title="1">root.addRoute(method, path, handler)</span>
}

// Lookup finds the route data for a given method and path.
func (a *App) Lookup(method, path string) (route *Route, params RouteParameters, slashRedirect bool) <span class="cov8" title="1">{
        if root := a.routes[method]; root != nil </span><span class="cov8" title="1">{
                return root.getValue(path)
        }</span>
        <span class="cov8" title="1">return nil, nil, false</span>
}

// ServeHTTP makes the router implement the http.Handler interface.
func (a *App) ServeHTTP(w http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        if a.recoverPanics </span><span class="cov8" title="1">{
                defer a.recover(w, req)
        }</span>

        <span class="cov8" title="1">path := req.URL.Path
        if root := a.routes[req.Method]; root != nil </span><span class="cov8" title="1">{
                if route, params, tsr := root.getValue(path); route != nil </span><span class="cov8" title="1">{
                        route.Handler(w, req, route, params, nil)
                        return
                }</span> else<span class="cov0" title="0"> if req.Method != MethodConnect &amp;&amp; path != "/" </span><span class="cov0" title="0">{
                        code := http.StatusMovedPermanently // 301 // Permanent redirect, request with GET method
                        if req.Method != MethodGet </span><span class="cov0" title="0">{
                                code = http.StatusTemporaryRedirect // 307
                        }</span>

                        <span class="cov0" title="0">if tsr &amp;&amp; a.redirectTrailingSlash </span><span class="cov0" title="0">{
                                if len(path) &gt; 1 &amp;&amp; path[len(path)-1] == '/' </span><span class="cov0" title="0">{
                                        req.URL.Path = path[:len(path)-1]
                                }</span> else<span class="cov0" title="0"> {
                                        req.URL.Path = path + "/"
                                }</span>
                                <span class="cov0" title="0">http.Redirect(w, req, req.URL.String(), code)
                                return</span>
                        }
                }
        }

        <span class="cov0" title="0">if req.Method == MethodOptions </span><span class="cov0" title="0">{
                // Handle OPTIONS requests
                if a.handleOptions </span><span class="cov0" title="0">{
                        if allow := a.allowed(path, req.Method); len(allow) &gt; 0 </span><span class="cov0" title="0">{
                                w.Header().Set(HeaderAllow, allow)
                                return
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                // Handle 405
                if a.handleMethodNotAllowed </span><span class="cov0" title="0">{
                        if allow := a.allowed(path, req.Method); len(allow) &gt; 0 </span><span class="cov0" title="0">{
                                w.Header().Set(HeaderAllow, allow)
                                if a.methodNotAllowedHandler != nil </span><span class="cov0" title="0">{
                                        a.methodNotAllowedHandler(w, req, nil, nil, nil)
                                }</span> else<span class="cov0" title="0"> {
                                        http.Error(w,
                                                http.StatusText(http.StatusMethodNotAllowed),
                                                http.StatusMethodNotAllowed,
                                        )
                                }</span>
                                <span class="cov0" title="0">return</span>
                        }
                }
        }

        // Handle 404
        <span class="cov0" title="0">if a.notFoundHandler != nil </span><span class="cov0" title="0">{
                a.notFoundHandler(w, req, nil, nil, nil)
        }</span> else<span class="cov0" title="0"> {
                http.NotFound(w, req)
        }</span>
}

// --------------------------------------------------------------------------------
// Request Pipeline
// --------------------------------------------------------------------------------

// renderAction is the translation step from Action to Handler.
// this is where the bulk of the "pipeline" happens.
func (a *App) renderAction(action Action) Handler <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request, route *Route, p RouteParameters, state State) </span><span class="cov8" title="1">{
                var err error

                if len(a.defaultHeaders) &gt; 0 </span><span class="cov8" title="1">{
                        for key, value := range a.defaultHeaders </span><span class="cov8" title="1">{
                                w.Header().Set(key, value)
                        }</span>
                }

                <span class="cov8" title="1">if a.hsts </span><span class="cov8" title="1">{
                        a.addHSTSHeader(w)
                }</span>

                <span class="cov8" title="1">var response ResponseWriter
                if strings.Contains(r.Header.Get(HeaderAcceptEncoding), ContentEncodingGZIP) </span><span class="cov8" title="1">{
                        w.Header().Set(HeaderContentEncoding, ContentEncodingGZIP)
                        response = NewCompressedResponseWriter(w)
                }</span> else<span class="cov8" title="1"> {
                        w.Header().Set(HeaderContentEncoding, ContentEncodingIdentity)
                        response = NewRawResponseWriter(w)
                }</span>

                <span class="cov8" title="1">ctx := a.createCtx(response, r, route, p, state)
                ctx.onRequestStart()
                if a.log != nil </span><span class="cov8" title="1">{
                        a.log.Trigger(a.loggerRequestStartEvent(ctx))
                }</span>

                <span class="cov8" title="1">result := action(ctx)
                if result != nil </span><span class="cov8" title="1">{
                        err = result.Render(ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                a.logError(err)
                        }</span>
                }

                <span class="cov8" title="1">ctx.onRequestEnd()
                ctx.setLoggedStatusCode(response.StatusCode())
                ctx.setLoggedContentLength(response.ContentLength())

                err = response.Close()
                if err != nil &amp;&amp; err != http.ErrBodyNotAllowed </span><span class="cov0" title="0">{
                        a.logError(err)
                }</span>

                // call the cancel func if it's set.
                <span class="cov8" title="1">if ctx.cancel != nil </span><span class="cov0" title="0">{
                        ctx.cancel()
                }</span>

                // effectively "request complete"
                <span class="cov8" title="1">if a.log != nil </span><span class="cov8" title="1">{
                        a.log.Trigger(a.loggerRequestEvent(ctx))
                }</span>
        }
}

// StartupTasks runs common startup tasks.
func (a *App) StartupTasks() error <span class="cov8" title="1">{
        if a.didRunStartupTasks </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">a.didRunStartupTasks = true
        return a.views.Initialize()</span>
}

func (a *App) addHSTSHeader(w http.ResponseWriter) <span class="cov8" title="1">{
        parts := []string{fmt.Sprintf(HSTSMaxAgeFormat, a.hstsMaxAgeSeconds)}
        if a.hstsIncludeSubdomains </span><span class="cov8" title="1">{
                parts = append(parts, HSTSIncludeSubDomains)
        }</span>
        <span class="cov8" title="1">if a.hstsPreload </span><span class="cov8" title="1">{
                parts = append(parts, HSTSPreload)
        }</span>
        <span class="cov8" title="1">w.Header().Set(HeaderStrictTransportSecurity, strings.Join(parts, "; "))</span>
}

func (a *App) loggerRequestStartEvent(ctx *Ctx) *logger.WebRequestEvent <span class="cov8" title="1">{
        event := logger.NewWebRequestStartEvent(ctx.Request()).
                WithState(ctx.state)

        if ctx.Route() != nil </span><span class="cov8" title="1">{
                event = event.WithRoute(ctx.Route().String())
        }</span>
        <span class="cov8" title="1">return event</span>
}

func (a *App) loggerRequestEvent(ctx *Ctx) *logger.WebRequestEvent <span class="cov8" title="1">{
        event := logger.NewWebRequestEvent(ctx.Request()).
                WithStatusCode(ctx.statusCode).
                WithElapsed(ctx.Elapsed()).
                WithContentLength(int64(ctx.contentLength)).
                WithState(ctx.state)

        if ctx.Route() != nil </span><span class="cov8" title="1">{
                event = event.WithRoute(ctx.Route().String())
        }</span>

        <span class="cov8" title="1">if ctx.Response().Header() != nil </span><span class="cov8" title="1">{
                event = event.WithContentType(ctx.Response().Header().Get(HeaderContentType))
                event = event.WithContentEncoding(ctx.Response().Header().Get(HeaderContentEncoding))
        }</span>
        <span class="cov8" title="1">return event</span>
}

func (a *App) recover(w http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        if rcv := recover(); rcv != nil </span><span class="cov0" title="0">{
                if a.log != nil </span><span class="cov0" title="0">{
                        a.log.Fatalf("%v", rcv)
                }</span>
                <span class="cov0" title="0">if a.panicAction != nil </span><span class="cov0" title="0">{
                        a.handlePanic(w, req, rcv)
                }</span>
        }
}

func (a *App) handlePanic(w http.ResponseWriter, r *http.Request, err interface{}) <span class="cov8" title="1">{
        a.renderAction(func(ctx *Ctx) Result </span><span class="cov8" title="1">{
                if a.log != nil </span><span class="cov0" title="0">{
                        a.log.Fatalf("%v", err)
                }</span>
                <span class="cov8" title="1">return a.panicAction(ctx, err)</span>
        })(w, r, nil, nil, nil)
}

func (a *App) createCtx(w ResponseWriter, r *http.Request, route *Route, p RouteParameters, s State) *Ctx <span class="cov8" title="1">{
        ctx := &amp;Ctx{
                response:        w,
                request:         r,
                app:             a,
                route:           route,
                routeParameters: p,
                state:           s,
                auth:            a.auth,
                log:             a.log,
                view:            a.viewProvider,
                json:            a.jsonProvider,
                xml:             a.xmlProvider,
                text:            a.textProvider,
                defaultResultProvider: a.defaultResultProvider,
        }

        if ctx.defaultResultProvider == nil </span><span class="cov8" title="1">{
                ctx.defaultResultProvider = a.textProvider
        }</span>
        <span class="cov8" title="1">if ctx.state == nil </span><span class="cov8" title="1">{
                ctx.state = State{}
        }</span>
        <span class="cov8" title="1">if a.state != nil &amp;&amp; len(a.state) &gt; 0 </span><span class="cov0" title="0">{
                for key, value := range a.state </span><span class="cov0" title="0">{
                        ctx.state[key] = value
                }</span>
        }

        <span class="cov8" title="1">return ctx</span>
}

func (a *App) middlewarePipeline(action Action, middleware ...Middleware) Action <span class="cov8" title="1">{
        if len(middleware) == 0 &amp;&amp; len(a.defaultMiddleware) == 0 </span><span class="cov8" title="1">{
                return action
        }</span>

        <span class="cov8" title="1">finalMiddleware := make([]Middleware, len(middleware)+len(a.defaultMiddleware))
        cursor := len(finalMiddleware) - 1
        for i := len(a.defaultMiddleware) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                finalMiddleware[cursor] = a.defaultMiddleware[i]
                cursor--
        }</span>

        <span class="cov8" title="1">for i := len(middleware) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                finalMiddleware[cursor] = middleware[i]
                cursor--
        }</span>

        <span class="cov8" title="1">return NestMiddleware(action, finalMiddleware...)</span>
}

func (a *App) allowed(path, reqMethod string) (allow string) <span class="cov0" title="0">{
        if path == "*" </span><span class="cov0" title="0">{ // server-wide
                for method := range a.routes </span><span class="cov0" title="0">{
                        if method == "OPTIONS" </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // add request method to list of allowed methods
                        <span class="cov0" title="0">if len(allow) == 0 </span><span class="cov0" title="0">{
                                allow = method
                        }</span> else<span class="cov0" title="0"> {
                                allow += ", " + method
                        }</span>
                }
                <span class="cov0" title="0">return</span>
        }
        <span class="cov0" title="0">for method := range a.routes </span><span class="cov0" title="0">{
                // Skip the requested method - we already tried this one
                if method == reqMethod || method == "OPTIONS" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">handle, _, _ := a.routes[method].getValue(path)
                if handle != nil </span><span class="cov0" title="0">{
                        // add request method to list of allowed methods
                        if len(allow) == 0 </span><span class="cov0" title="0">{
                                allow = method
                        }</span> else<span class="cov0" title="0"> {
                                allow += ", " + method
                        }</span>
                }
        }
        <span class="cov0" title="0">if len(allow) &gt; 0 </span><span class="cov0" title="0">{
                allow += ", OPTIONS"
        }</span>
        <span class="cov0" title="0">return</span>
}

func (a *App) logError(err error) <span class="cov0" title="0">{
        if a.log == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                a.log.Error(err)
        }</span>
}

func (a *App) syncInfof(format string, args ...interface{}) <span class="cov8" title="1">{
        if a.log == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">a.log.SyncInfof(format, args...)</span>
}

func (a *App) syncFatalf(format string, args ...interface{}) <span class="cov0" title="0">{
        if a.log == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">a.log.SyncFatalf(format, args...)</span>
}

func (a *App) setRunning() <span class="cov8" title="1">{
        close(a.started)
        atomic.StoreInt32(&amp;a.running, 1)
}</span>

func (a *App) setStopped() <span class="cov8" title="1">{
        atomic.StoreInt32(&amp;a.running, 0)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package web

import (
        "bytes"
        "fmt"
        "time"

        "github.com/blend/go-sdk/logger"
)

const (
        // AppStart fires when the app is starting.
        AppStart logger.Flag = "web.app.start"
        // AppStartComplete fires after the app has started.
        AppStartComplete logger.Flag = "web.app.start.complete"
        // AppExit fires when an app exits.
        AppExit logger.Flag = "web.app.exit"
)

const (
        // HealthzStart is a logger event.
        HealthzStart logger.Flag = "web.healthz.start"
        // HealthzStartComplete is a logger event.
        HealthzStartComplete logger.Flag = "web.healthz.start.complete"
        // HealthzExit is a logger event.
        HealthzExit logger.Flag = "web.healthz.exit"
)

const (
        // HTTPSUpgraderStart is a logger event.
        HTTPSUpgraderStart logger.Flag = "web.upgrader.start"
        // HTTPSUpgraderStartComplete is a logger event.
        HTTPSUpgraderStartComplete logger.Flag = "web.upgrader.start.complete"
        // HTTPSUpgraderExit is a logger event.
        HTTPSUpgraderExit logger.Flag = "web.upgrader.exit"
)

// NewAppEvent creates a new app start event.
func NewAppEvent(flag logger.Flag) *AppEvent <span class="cov8" title="1">{
        return &amp;AppEvent{
                flag: flag,
                ts:   time.Now().UTC(),
        }
}</span>

// NewAppEventListener returns a new app start event listener.
func NewAppEventListener(listener func(me *AppEvent)) logger.Listener <span class="cov8" title="1">{
        return func(e logger.Event) </span><span class="cov8" title="1">{
                if typed, isTyped := e.(*AppEvent); isTyped </span><span class="cov8" title="1">{
                        listener(typed)
                }</span>
        }
}

// AppEvent is an event.
type AppEvent struct {
        flag     logger.Flag
        ts       time.Time
        app      *App
        hz       *Healthz
        upgrader *HTTPSUpgrader
        elapsed  time.Duration
        err      error
}

// WithFlag sets the event flag.
func (ae *AppEvent) WithFlag(flag logger.Flag) *AppEvent <span class="cov0" title="0">{
        ae.flag = flag
        return ae
}</span>

// Flag returns the logger flag.
func (ae *AppEvent) Flag() logger.Flag <span class="cov8" title="1">{
        return ae.flag
}</span>

// WithTimestamp sets the event timestamp.
func (ae *AppEvent) WithTimestamp(ts time.Time) *AppEvent <span class="cov0" title="0">{
        ae.ts = ts
        return ae
}</span>

// Timestamp returns the timestamp for a
func (ae *AppEvent) Timestamp() time.Time <span class="cov0" title="0">{
        return ae.ts
}</span>

// WithApp sets the event app reference.
func (ae *AppEvent) WithApp(app *App) *AppEvent <span class="cov8" title="1">{
        ae.app = app
        return ae
}</span>

// App returns the app reference.
func (ae AppEvent) App() *App <span class="cov0" title="0">{
        return ae.app
}</span>

// WithHealthz sets the event hz reference.
func (ae *AppEvent) WithHealthz(hz *Healthz) *AppEvent <span class="cov8" title="1">{
        ae.hz = hz
        return ae
}</span>

// Healthz returns the healthz reference.
func (ae AppEvent) Healthz() *Healthz <span class="cov0" title="0">{
        return ae.hz
}</span>

// WithUpgrader sets the event hz reference.
func (ae *AppEvent) WithUpgrader(upgrader *HTTPSUpgrader) *AppEvent <span class="cov0" title="0">{
        ae.upgrader = upgrader
        return ae
}</span>

// Upgrader returns the https upgrader reference.
func (ae AppEvent) Upgrader() *HTTPSUpgrader <span class="cov0" title="0">{
        return ae.upgrader
}</span>

// WithErr sets the event error.
func (ae *AppEvent) WithErr(err error) *AppEvent <span class="cov8" title="1">{
        ae.err = err
        return ae
}</span>

// Err returns an underlying error.
func (ae *AppEvent) Err() error <span class="cov0" title="0">{
        return ae.err
}</span>

// WithElapsed sets the elapsed time on the event.
func (ae *AppEvent) WithElapsed(elapsed time.Duration) *AppEvent <span class="cov8" title="1">{
        ae.elapsed = elapsed
        return ae
}</span>

// Elapsed returns the elapsed time.
func (ae *AppEvent) Elapsed() time.Duration <span class="cov0" title="0">{
        return ae.elapsed
}</span>

// WriteText implements logger.TextWritable.
func (ae *AppEvent) WriteText(tf logger.TextFormatter, buf *bytes.Buffer) <span class="cov0" title="0">{
        if ae.elapsed &gt; 0 </span><span class="cov0" title="0">{
                if ae.err != nil </span><span class="cov0" title="0">{
                        buf.WriteString(tf.Colorize("failed", logger.ColorRed))
                        buf.WriteRune(logger.RuneNewline)
                        buf.WriteString(fmt.Sprintf("%+v", ae.err))
                }</span> else<span class="cov0" title="0"> {
                        buf.WriteString(tf.Colorize("complete", logger.ColorBlue))
                }</span>

                <span class="cov0" title="0">buf.WriteRune(logger.RuneSpace)
                buf.WriteString(fmt.Sprintf("(%v)", ae.elapsed))</span>
        }
}

// WriteJSON implements logger.JSONWritable.
func (ae *AppEvent) WriteJSON() logger.JSONObj <span class="cov0" title="0">{
        obj := logger.JSONObj{}
        if ae.err != nil </span><span class="cov0" title="0">{
                obj[logger.JSONFieldErr] = ae.err
        }</span>
        <span class="cov0" title="0">if ae.elapsed &gt; 0 </span><span class="cov0" title="0">{
                obj[logger.JSONFieldElapsed] = ae.elapsed
        }</span>
        <span class="cov0" title="0">return obj</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package web

import (
        "crypto/hmac"
        "net/url"
        "time"

        "github.com/blend/go-sdk/logger"
        "github.com/blend/go-sdk/util"
)

// NewAuthManager returns a new session manager.
func NewAuthManager() *AuthManager <span class="cov8" title="1">{
        return &amp;AuthManager{
                sessionCache:             NewSessionCache(),
                useSessionCache:          DefaultUseSessionCache,
                sessionTimeout:           DefaultSessionTimeout,
                sessionTimeoutIsAbsolute: DefaultSessionTimeoutIsAbsolute,
                cookieName:               DefaultCookieName,
                cookiePath:               DefaultCookiePath,
                secureCookieName:         DefaultSecureCookieName,
        }
}</span>

// NewAuthManagerFromConfig returns a new auth manager from a given config.
func NewAuthManagerFromConfig(cfg *Config) *AuthManager <span class="cov8" title="1">{
        return &amp;AuthManager{
                sessionCache:             NewSessionCache(),
                useSessionCache:          cfg.GetUseSessionCache(),
                sessionTimeout:           cfg.GetSessionTimeout(),
                sessionTimeoutIsAbsolute: cfg.GetSessionTimeoutIsAbsolute(),
                cookieHTTPSOnly:          cfg.GetCookieHTTPSOnly(),
                cookieName:               cfg.GetCookieName(),
                cookiePath:               cfg.GetCookiePath(),
                secret:                   cfg.GetAuthSecret(),
                secureCookieHTTPSOnly:    cfg.GetSecureCookieHTTPSOnly(),
                secureCookieName:         cfg.GetSecureCookieName(),
        }
}</span>

// AuthManager is a manager for sessions.
type AuthManager struct {
        useSessionCache      bool
        sessionCache         *SessionCache
        persistHandler       func(*Ctx, *Session, State) error
        fetchHandler         func(sessionID string, state State) (*Session, error)
        removeHandler        func(sessionID string, state State) error
        validateHandler      func(*Session, State) error
        loginRedirectHandler func(*Ctx) *url.URL

        log *logger.Logger

        sessionTimeout           time.Duration
        sessionTimeoutIsAbsolute bool
        sessionTimeoutProvider   func(rc *Ctx) *time.Time

        cookieName      string
        cookiePath      string
        cookieHTTPSOnly bool

        secret                []byte
        secureCookieName      string
        secureCookieHTTPSOnly bool
}

// --------------------------------------------------------------------------------
// Methods
// --------------------------------------------------------------------------------

// Login logs a userID in.
func (am *AuthManager) Login(userID string, ctx *Ctx) (session *Session, err error) <span class="cov8" title="1">{
        var sessionID string
        var secureSessionID string

        sessionID = am.createSessionID()
        if am.shouldIssueSecureSesssionID() </span><span class="cov8" title="1">{
                secureSessionID, err = am.createSecureSessionID(sessionID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">session = NewSession(userID, sessionID)
        session.ExpiresUTC = am.GenerateSessionTimeout(ctx)

        if am.persistHandler != nil </span><span class="cov8" title="1">{
                err = am.persistHandler(ctx, session, ctx.state)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, am.err(err)
                }</span>
        }

        <span class="cov8" title="1">if am.useSessionCache </span><span class="cov8" title="1">{
                am.sessionCache.Upsert(session)
        }</span>

        <span class="cov8" title="1">am.injectCookie(ctx, am.CookieName(), sessionID, session.ExpiresUTC)
        if am.shouldIssueSecureSesssionID() </span><span class="cov8" title="1">{
                am.injectCookie(ctx, am.SecureCookieName(), secureSessionID, session.ExpiresUTC)
        }</span>
        <span class="cov8" title="1">return session, nil</span>
}

// Logout unauthenticates a session.
func (am *AuthManager) Logout(ctx *Ctx) error <span class="cov8" title="1">{
        sessionID := am.readSessionID(ctx)

        // remove from session cache if enabled
        if am.useSessionCache </span><span class="cov8" title="1">{
                am.sessionCache.Remove(sessionID)
        }</span>

        <span class="cov8" title="1">ctx.ExpireCookie(am.CookieName(), am.CookiePath())
        if am.shouldIssueSecureSesssionID() </span><span class="cov8" title="1">{
                ctx.ExpireCookie(am.SecureCookieName(), am.CookiePath())
        }</span>
        <span class="cov8" title="1">ctx.WithSession(nil)

        // remove the session from a backing store
        if am.removeHandler != nil </span><span class="cov8" title="1">{
                return am.err(am.removeHandler(sessionID, ctx.state))
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// VerifySession checks a sessionID to see if it's valid.
// It also handles updating a rolling expiry.
func (am *AuthManager) VerifySession(ctx *Ctx) (*Session, error) <span class="cov8" title="1">{
        sessionID := am.readSessionID(ctx)
        err := am.validateSessionID(sessionID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var secureSessionID string
        if am.shouldIssueSecureSesssionID() </span><span class="cov8" title="1">{
                secureSessionID = am.readSecureSessionID(ctx)
                err := am.validateSecureSessionID(sessionID, secureSessionID)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">var session *Session
        if am.useSessionCache </span><span class="cov8" title="1">{
                session = am.sessionCache.Get(sessionID)
        }</span>

        <span class="cov8" title="1">if session == nil &amp;&amp; am.fetchHandler != nil </span><span class="cov8" title="1">{
                session, err = am.fetchHandler(sessionID, ctx.state)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">if session == nil || session.IsZero() || session.IsExpired() </span><span class="cov8" title="1">{
                ctx.ExpireCookie(am.CookieName(), DefaultCookiePath)
                if am.shouldIssueSecureSesssionID() </span><span class="cov8" title="1">{
                        ctx.ExpireCookie(am.SecureCookieName(), am.CookiePath())
                }</span>

                // if we have a remove handler and the sessionID is set
                <span class="cov8" title="1">if am.removeHandler != nil </span><span class="cov8" title="1">{
                        err = am.removeHandler(sessionID, ctx.state)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }

                // exit out, the session is bad
                <span class="cov8" title="1">return nil, nil</span>
        }

        <span class="cov8" title="1">if am.validateHandler != nil </span><span class="cov8" title="1">{
                err = am.validateHandler(session, ctx.state)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // check if we need to do a rolling expiry update
        // note this will be explicitly false by default
        // as we use absolte expiry by default.
        <span class="cov8" title="1">if am.shouldUpdateSessionExpiry() </span><span class="cov8" title="1">{
                session.ExpiresUTC = am.GenerateSessionTimeout(ctx)
                if am.persistHandler != nil </span><span class="cov8" title="1">{
                        err = am.persistHandler(ctx, session, ctx.state)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }

                <span class="cov8" title="1">am.injectCookie(ctx, am.CookieName(), sessionID, session.ExpiresUTC)
                if am.shouldIssueSecureSesssionID() </span><span class="cov0" title="0">{
                        am.injectCookie(ctx, am.SecureCookieName(), secureSessionID, session.ExpiresUTC)
                }</span>
        }

        <span class="cov8" title="1">if am.useSessionCache </span><span class="cov8" title="1">{
                am.sessionCache.Upsert(session)
        }</span>
        <span class="cov8" title="1">return session, nil</span>
}

// Redirect returns a redirect result for when auth fails and you need to
// send the user to a login page.
func (am *AuthManager) Redirect(ctx *Ctx) Result <span class="cov8" title="1">{
        if am.loginRedirectHandler != nil </span><span class="cov0" title="0">{
                redirectTo := am.loginRedirectHandler(ctx)
                if redirectTo != nil </span><span class="cov0" title="0">{
                        return ctx.Redirectf(redirectTo.String())
                }</span>
        }
        <span class="cov8" title="1">return ctx.DefaultResultProvider().NotAuthorized()</span>
}

// --------------------------------------------------------------------------------
// Properties
// --------------------------------------------------------------------------------

// WithUseSessionCache sets if we should use the session cache.
func (am *AuthManager) WithUseSessionCache(value bool) *AuthManager <span class="cov8" title="1">{
        am.SetUseSessionCache(value)
        return am
}</span>

// SetUseSessionCache sets the `UseSessionCache` property to the value.
func (am *AuthManager) SetUseSessionCache(value bool) <span class="cov8" title="1">{
        am.useSessionCache = value
}</span>

// UseSessionCache returns if we should use the session cache.
func (am *AuthManager) UseSessionCache() bool <span class="cov8" title="1">{
        return am.useSessionCache
}</span>

// WithSecret sets the secret for the auth manager.
func (am *AuthManager) WithSecret(secret []byte) *AuthManager <span class="cov8" title="1">{
        am.SetSecret(secret)
        return am
}</span>

// SetSecret sets the secret for the auth manager.
func (am *AuthManager) SetSecret(secret []byte) <span class="cov8" title="1">{
        am.secret = secret
}</span>

// Secret returns the auth manager secret.
func (am *AuthManager) Secret() []byte <span class="cov8" title="1">{
        return am.secret
}</span>

// WithCookiesAsSessionBound sets cookies to be issued with `session` liveness.
func (am *AuthManager) WithCookiesAsSessionBound() *AuthManager <span class="cov0" title="0">{
        am.SetCookiesAsSessionBound()
        return am
}</span>

// SetCookiesAsSessionBound sets the session issued cookies to be deleted after the browser closes.
func (am *AuthManager) SetCookiesAsSessionBound() <span class="cov0" title="0">{
        am.sessionTimeout = 0
        am.sessionTimeoutProvider = nil
}</span>

// CookiesAsSessionBound returns if cookies are issued with `session` liveness.
func (am *AuthManager) CookiesAsSessionBound() bool <span class="cov0" title="0">{
        return am.sessionTimeout == 0 &amp;&amp; am.sessionTimeoutProvider == nil
}</span>

// WithSessionTimeout sets the either rolling or absolute session timeout.
func (am *AuthManager) WithSessionTimeout(timeout time.Duration) *AuthManager <span class="cov0" title="0">{
        am.SetSessionTimeout(timeout)
        return am
}</span>

// SetSessionTimeout sets the static value for session timeout.
func (am *AuthManager) SetSessionTimeout(timeout time.Duration) <span class="cov8" title="1">{
        am.sessionTimeout = timeout
}</span>

// SessionTimeout returns the session timeout.
func (am *AuthManager) SessionTimeout() time.Duration <span class="cov0" title="0">{
        return am.sessionTimeout
}</span>

// WithAbsoluteSessionTimeout sets if the session timeout is absolute (vs. rolling).
func (am *AuthManager) WithAbsoluteSessionTimeout() *AuthManager <span class="cov0" title="0">{
        am.SetSessionTimeoutIsAbsolute(true)
        return am
}</span>

// WithRollingSessionTimeout sets if the session timeout to be rolling (i.e. rolling).
func (am *AuthManager) WithRollingSessionTimeout() *AuthManager <span class="cov8" title="1">{
        am.SetSessionTimeoutIsAbsolute(false)
        return am
}</span>

// SetSessionTimeoutIsAbsolute sets if the timeout for session should be an absolute (vs. rolling) time.
func (am *AuthManager) SetSessionTimeoutIsAbsolute(isAbsolute bool) <span class="cov8" title="1">{
        am.sessionTimeoutIsAbsolute = isAbsolute
}</span>

// SesssionTimeoutIsAbsolute returns if the session timeout is absolute (vs. rolling).
func (am *AuthManager) SesssionTimeoutIsAbsolute() bool <span class="cov0" title="0">{
        return am.sessionTimeoutIsAbsolute
}</span>

// SesssionTimeoutIsRolling returns if the session timeout is absolute (vs. rolling).
func (am *AuthManager) SesssionTimeoutIsRolling() bool <span class="cov8" title="1">{
        return !am.sessionTimeoutIsAbsolute
}</span>

// WithSessionTimeoutProvider sets the session timeout provider.
func (am *AuthManager) WithSessionTimeoutProvider(timeoutProvider func(rc *Ctx) *time.Time) *AuthManager <span class="cov8" title="1">{
        am.SetSessionTimeoutProvider(timeoutProvider)
        return am
}</span>

// SetSessionTimeoutProvider sets the session to expire with a given the given timeout provider.
func (am *AuthManager) SetSessionTimeoutProvider(timeoutProvider func(rc *Ctx) *time.Time) <span class="cov8" title="1">{
        am.sessionTimeoutProvider = timeoutProvider
}</span>

// SessionTimeoutProvider returns the session timeout provider.
func (am *AuthManager) SessionTimeoutProvider() func(rc *Ctx) *time.Time <span class="cov0" title="0">{
        return am.sessionTimeoutProvider
}</span>

// WithCookiesHTTPSOnly sets if we should issue cookies with the HTTPS flag on.
func (am *AuthManager) WithCookiesHTTPSOnly(isHTTPSOnly bool) *AuthManager <span class="cov8" title="1">{
        am.cookieHTTPSOnly = isHTTPSOnly
        return am
}</span>

// SetCookieHTTPSOnly overrides defaults when determining if we should use the HTTPS only cooikie option.
// The default depends on the app configuration (if tls is configured and enabled).
func (am *AuthManager) SetCookieHTTPSOnly(isHTTPSOnly bool) <span class="cov0" title="0">{
        am.cookieHTTPSOnly = isHTTPSOnly
}</span>

// CookiesHTTPSOnly returns if the cookie is for only https connections.
func (am *AuthManager) CookiesHTTPSOnly() bool <span class="cov8" title="1">{
        return am.cookieHTTPSOnly
}</span>

// WithCookieName sets the cookie name.
func (am *AuthManager) WithCookieName(paramName string) *AuthManager <span class="cov0" title="0">{
        am.SetCookieName(paramName)
        return am
}</span>

// SetCookieName sets the session cookie name.
func (am *AuthManager) SetCookieName(paramName string) <span class="cov8" title="1">{
        am.cookieName = paramName
}</span>

// CookieName returns the session param name.
func (am *AuthManager) CookieName() string <span class="cov8" title="1">{
        return am.cookieName
}</span>

// WithCookiePath sets the cookie path.
func (am *AuthManager) WithCookiePath(path string) *AuthManager <span class="cov0" title="0">{
        am.SetCookiePath(path)
        return am
}</span>

// SetCookiePath sets the session cookie path.
func (am *AuthManager) SetCookiePath(path string) <span class="cov0" title="0">{
        am.cookiePath = path
}</span>

// CookiePath returns the session param path.
func (am *AuthManager) CookiePath() string <span class="cov8" title="1">{
        if len(am.cookiePath) == 0 </span><span class="cov0" title="0">{
                return DefaultCookiePath
        }</span>
        <span class="cov8" title="1">return am.cookiePath</span>
}

// WithSecureCookieName sets the secure cookie name.
func (am *AuthManager) WithSecureCookieName(paramName string) *AuthManager <span class="cov0" title="0">{
        am.SetSecureCookieName(paramName)
        return am
}</span>

// SetSecureCookieName sets the session param name.
func (am *AuthManager) SetSecureCookieName(paramName string) <span class="cov0" title="0">{
        am.secureCookieName = paramName
}</span>

// SecureCookieName returns the session param name.
func (am *AuthManager) SecureCookieName() string <span class="cov8" title="1">{
        return am.secureCookieName
}</span>

// WithPersistHandler sets the persist handler.
func (am *AuthManager) WithPersistHandler(handler func(*Ctx, *Session, State) error) *AuthManager <span class="cov8" title="1">{
        am.SetPersistHandler(handler)
        return am
}</span>

// SetPersistHandler sets the persist handler.
// It must be able to both create sessions and update sessions if the expiry changes.
func (am *AuthManager) SetPersistHandler(handler func(*Ctx, *Session, State) error) <span class="cov8" title="1">{
        am.persistHandler = handler
}</span>

// PersistHandler returns the persist handler.
func (am *AuthManager) PersistHandler() func(*Ctx, *Session, State) error <span class="cov0" title="0">{
        return am.persistHandler
}</span>

// WithFetchHandler sets the fetch handler.
func (am *AuthManager) WithFetchHandler(handler func(sessionID string, state State) (*Session, error)) *AuthManager <span class="cov8" title="1">{
        am.fetchHandler = handler
        return am
}</span>

// SetFetchHandler sets the fetch handler.
func (am *AuthManager) SetFetchHandler(handler func(sessionID string, state State) (*Session, error)) <span class="cov8" title="1">{
        am.fetchHandler = handler
}</span>

// FetchHandler returns the fetch handler.
// It is used in `VerifySession` to satisfy session cache misses.
func (am *AuthManager) FetchHandler() func(sessionID string, state State) (*Session, error) <span class="cov0" title="0">{
        return am.fetchHandler
}</span>

// WithRemoveHandler sets the remove handler.
func (am *AuthManager) WithRemoveHandler(handler func(sessionID string, state State) error) *AuthManager <span class="cov8" title="1">{
        am.SetRemoveHandler(handler)
        return am
}</span>

// SetRemoveHandler sets the remove handler.
// It should remove a session from the backing store by a string sessionID.
func (am *AuthManager) SetRemoveHandler(handler func(sessionID string, state State) error) <span class="cov8" title="1">{
        am.removeHandler = handler
}</span>

// RemoveHandler returns the remove handler.
// It is used in validate session if the session is found to be invalid.
func (am *AuthManager) RemoveHandler() func(sessionID string, state State) error <span class="cov0" title="0">{
        return am.removeHandler
}</span>

// WithValidateHandler sets the validate handler.
func (am *AuthManager) WithValidateHandler(handler func(*Session, State) error) *AuthManager <span class="cov8" title="1">{
        am.SetValidateHandler(handler)
        return am
}</span>

// SetValidateHandler sets the validate handler.
// This is an optional handler that will evaluate the session when verifying requests that are session aware.
func (am *AuthManager) SetValidateHandler(handler func(*Session, State) error) <span class="cov8" title="1">{
        am.validateHandler = handler
}</span>

// ValidateHandler returns the validate handler.
func (am *AuthManager) ValidateHandler() func(*Session, State) error <span class="cov0" title="0">{
        return am.validateHandler
}</span>

// WithLoginRedirectHandler sets the login redirect handler.
func (am *AuthManager) WithLoginRedirectHandler(handler func(*Ctx) *url.URL) *AuthManager <span class="cov0" title="0">{
        am.SetLoginRedirectHandler(handler)
        return am
}</span>

// SetLoginRedirectHandler sets the handler to determin where to redirect on not authorized attempts.
// It should return (nil) if you want to just show the `not_authorized` template, provided one is configured.
func (am *AuthManager) SetLoginRedirectHandler(handler func(*Ctx) *url.URL) <span class="cov0" title="0">{
        am.loginRedirectHandler = handler
}</span>

// LoginRedirectHandler returns the login redirect handler.
func (am *AuthManager) LoginRedirectHandler() func(*Ctx) *url.URL <span class="cov0" title="0">{
        return am.loginRedirectHandler
}</span>

// SessionCache returns the session cache.
func (am *AuthManager) SessionCache() *SessionCache <span class="cov8" title="1">{
        return am.sessionCache
}</span>

// WithLogger sets the intance logger and returns a reference.
func (am *AuthManager) WithLogger(log *logger.Logger) *AuthManager <span class="cov0" title="0">{
        am.log = log
        return am
}</span>

// SetLogger sets the intance logger.
func (am *AuthManager) SetLogger(log *logger.Logger) <span class="cov0" title="0">{
        am.log = log
}</span>

// Logger returns the instance logger.
func (am *AuthManager) Logger() *logger.Logger <span class="cov0" title="0">{
        return am.log
}</span>

// --------------------------------------------------------------------------------
// Utility Methods
// --------------------------------------------------------------------------------

// GenerateSessionTimeout returns the absolute time the cookie would expire.
func (am *AuthManager) GenerateSessionTimeout(context *Ctx) *time.Time <span class="cov8" title="1">{
        if am.sessionTimeout &gt; 0 </span><span class="cov8" title="1">{
                return util.OptionalTime(time.Now().UTC().Add(am.sessionTimeout))
        }</span> else<span class="cov8" title="1"> if am.sessionTimeoutProvider != nil </span><span class="cov8" title="1">{
                return am.sessionTimeoutProvider(context)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (am *AuthManager) shouldIssueSecureSesssionID() bool <span class="cov8" title="1">{
        return len(am.secret) &gt; 0
}</span>

func (am AuthManager) shouldUpdateSessionExpiry() bool <span class="cov8" title="1">{
        return am.SesssionTimeoutIsRolling() &amp;&amp; (am.sessionTimeout &gt; 0 || am.sessionTimeoutProvider != nil)
}</span>

// CreateSessionID creates a new session id.
func (am AuthManager) createSessionID() string <span class="cov8" title="1">{
        return NewSessionID()
}</span>

// CreateSecureSessionID creates a secure session id.
func (am AuthManager) createSecureSessionID(sessionID string) (string, error) <span class="cov8" title="1">{
        return EncodeSignSessionID(sessionID, am.secret)
}</span>

// InjectCookie injects a session cookie into the context.
func (am *AuthManager) injectCookie(ctx *Ctx, name, value string, expire *time.Time) <span class="cov8" title="1">{
        path := am.CookiePath()
        https := am.CookiesHTTPSOnly()
        ctx.WriteNewCookie(name, value, expire, path, https)
}</span>

// readParam reads a param from a given request context from either the cookies or headers.
func (am *AuthManager) readParam(name string, ctx *Ctx) string <span class="cov8" title="1">{
        if cookie := ctx.GetCookie(name); cookie != nil </span><span class="cov8" title="1">{
                return cookie.Value
        }</span>
        <span class="cov8" title="1">return ""</span>
}

// ReadSessionID reads a session id from a given request context.
func (am *AuthManager) readSessionID(ctx *Ctx) string <span class="cov8" title="1">{
        return am.readParam(am.CookieName(), ctx)
}</span>

// ReadSecureSessionID reads a secure session id from a given request context.
func (am *AuthManager) readSecureSessionID(ctx *Ctx) string <span class="cov8" title="1">{
        return am.readParam(am.SecureCookieName(), ctx)
}</span>

// ValidateSessionID verifies a session id.
func (am *AuthManager) validateSessionID(sessionID string) error <span class="cov8" title="1">{
        if len(sessionID) == 0 </span><span class="cov8" title="1">{
                return ErrSessionIDEmpty
        }</span>
        <span class="cov8" title="1">if len(sessionID) &gt; LenSessionIDBase64 </span><span class="cov8" title="1">{
                return ErrSessionIDTooLong
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ValidateSecureSessionID verifies a session id.
func (am *AuthManager) validateSecureSessionID(sessionID, secureSessionID string) error <span class="cov8" title="1">{
        if len(secureSessionID) == 0 </span><span class="cov8" title="1">{
                return ErrSecureSessionIDEmpty
        }</span>

        <span class="cov8" title="1">if len(secureSessionID) &gt; LenSessionIDBase64 </span><span class="cov8" title="1">{
                return ErrSecureSessionIDTooLong
        }</span>

        <span class="cov8" title="1">secureSessionIDDecoded, err := Base64Decode(secureSessionID)
        if err != nil </span><span class="cov0" title="0">{
                return ErrSecureSessionIDInvalid
        }</span>

        <span class="cov8" title="1">signedSessionID, err := SignSessionID(sessionID, am.secret)
        if err != nil </span><span class="cov0" title="0">{
                return ErrSecureSessionIDInvalid
        }</span>

        <span class="cov8" title="1">if !hmac.Equal(signedSessionID, secureSessionIDDecoded) </span><span class="cov8" title="1">{
                return ErrSecureSessionIDInvalid
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (am AuthManager) debugf(format string, args ...interface{}) <span class="cov0" title="0">{
        if am.log != nil </span><span class="cov0" title="0">{
                am.log.SyncDebugf(format, args...)
        }</span>
}

func (am AuthManager) err(err error) error <span class="cov8" title="1">{
        if am.log != nil &amp;&amp; err != nil </span><span class="cov0" title="0">{
                am.log.Error(err)
        }</span>
        <span class="cov8" title="1">return err</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package web

import (
        "bytes"
        "net/http"
        "time"
)

// CachedStaticFile is a memory mapped static file.
type CachedStaticFile struct {
        Path     string
        Size     int
        ModTime  time.Time
        Contents *bytes.Reader
}

// Render implements Result.
func (csf CachedStaticFile) Render(ctx *Ctx) error <span class="cov0" title="0">{
        http.ServeContent(ctx.Response(), ctx.Request(), csf.Path, csf.ModTime, csf.Contents)
        return nil
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package web

import (
        "bytes"
        "io/ioutil"
        "net/http"
        "os"
        "regexp"
        "sync"

        "github.com/blend/go-sdk/logger"
)

// NewCachedStaticFileServer returns a new static file cache.
func NewCachedStaticFileServer(fs http.FileSystem) *CachedStaticFileServer <span class="cov8" title="1">{
        return &amp;CachedStaticFileServer{
                fileSystem: fs,
                files:      map[string]*CachedStaticFile{},
        }
}</span>

// CachedStaticFileServer  is a cache of static files.
type CachedStaticFileServer struct {
        log          *logger.Logger
        fileSystem   http.FileSystem
        syncRoot     sync.Mutex
        rewriteRules []RewriteRule
        headers      http.Header
        middleware   Action
        files        map[string]*CachedStaticFile
}

// Log returns a logger reference.
func (csfs *CachedStaticFileServer) Log() *logger.Logger <span class="cov0" title="0">{
        return csfs.log
}</span>

// WithLogger sets the logger reference for the static file cache.
func (csfs *CachedStaticFileServer) WithLogger(log *logger.Logger) *CachedStaticFileServer <span class="cov0" title="0">{
        csfs.log = log
        return csfs
}</span>

// Files returns the underlying file cache.
// Pragma; this should only be used in debugging, as during runtime locks are required to interact with this cache.
func (csfs *CachedStaticFileServer) Files() map[string]*CachedStaticFile <span class="cov0" title="0">{
        return csfs.files
}</span>

// AddHeader adds a header to the static cache results.
func (csfs *CachedStaticFileServer) AddHeader(key, value string) <span class="cov8" title="1">{
        if csfs.headers == nil </span><span class="cov8" title="1">{
                csfs.headers = http.Header{}
        }</span>
        <span class="cov8" title="1">csfs.headers[key] = append(csfs.headers[key], value)</span>
}

// Headers returns the headers for the static server.
func (csfs *CachedStaticFileServer) Headers() http.Header <span class="cov8" title="1">{
        return csfs.headers
}</span>

// AddRewriteRule adds a static re-write rule.
func (csfs *CachedStaticFileServer) AddRewriteRule(match string, action RewriteAction) error <span class="cov8" title="1">{
        expr, err := regexp.Compile(match)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">csfs.rewriteRules = append(csfs.rewriteRules, RewriteRule{
                MatchExpression: match,
                expr:            expr,
                Action:          action,
        })
        return nil</span>
}

// RewriteRules returns the rewrite rules
func (csfs *CachedStaticFileServer) RewriteRules() []RewriteRule <span class="cov0" title="0">{
        return csfs.rewriteRules
}</span>

// SetMiddleware sets the middlewares.
func (csfs *CachedStaticFileServer) SetMiddleware(middlewares ...Middleware) <span class="cov8" title="1">{
        csfs.middleware = NestMiddleware(csfs.ServeFile, middlewares...)
}</span>

// GetCachedFile returns a file from the filesystem at a given path.
func (csfs *CachedStaticFileServer) GetCachedFile(filepath string) (*CachedStaticFile, error) <span class="cov8" title="1">{
        csfs.syncRoot.Lock()
        defer csfs.syncRoot.Unlock()

        if file, hasFile := csfs.files[filepath]; hasFile </span><span class="cov8" title="1">{
                return file, nil
        }</span>

        <span class="cov8" title="1">f, err := csfs.fileSystem.Open(filepath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer f.Close()

        d, err := f.Stat()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">contents, err := ioutil.ReadAll(f)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">newFile := &amp;CachedStaticFile{
                Path:     filepath,
                Size:     len(contents),
                ModTime:  d.ModTime(),
                Contents: bytes.NewReader(contents),
        }

        csfs.files[filepath] = newFile
        return newFile, nil</span>
}

// Action is the entrypoint for the static server.
func (csfs *CachedStaticFileServer) Action(r *Ctx) Result <span class="cov8" title="1">{
        if csfs.middleware != nil </span><span class="cov8" title="1">{
                return csfs.middleware(r)
        }</span>
        <span class="cov8" title="1">return csfs.ServeFile(r)</span>
}

// ServeFile writes the file to the response.
func (csfs *CachedStaticFileServer) ServeFile(r *Ctx) Result <span class="cov8" title="1">{
        filePath, err := r.RouteParam(RouteTokenFilepath)
        if err != nil </span><span class="cov0" title="0">{
                return r.DefaultResultProvider().InternalError(err)
        }</span>

        <span class="cov8" title="1">for key, values := range csfs.headers </span><span class="cov8" title="1">{
                for _, value := range values </span><span class="cov8" title="1">{
                        r.Response().Header().Set(key, value)
                }</span>
        }

        <span class="cov8" title="1">for _, rule := range csfs.rewriteRules </span><span class="cov8" title="1">{
                if matched, newFilePath := rule.Apply(filePath); matched </span><span class="cov8" title="1">{
                        filePath = newFilePath
                }</span>
        }

        <span class="cov8" title="1">f, err := csfs.GetCachedFile(filePath)
        if f == nil || os.IsNotExist(err) </span><span class="cov0" title="0">{
                return r.DefaultResultProvider().NotFound()
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return r.DefaultResultProvider().InternalError(err)
        }</span>

        <span class="cov8" title="1">http.ServeContent(r.Response(), r.Request(), filePath, f.ModTime, f.Contents)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package web

import (
        "compress/gzip"
        "net/http"
)

// NewCompressedResponseWriter returns a new gzipped response writer.
func NewCompressedResponseWriter(w http.ResponseWriter) *CompressedResponseWriter <span class="cov8" title="1">{
        return &amp;CompressedResponseWriter{
                innerResponse: w,
        }
}</span>

// CompressedResponseWriter is a response writer that compresses output.
type CompressedResponseWriter struct {
        gzipWriter    *gzip.Writer
        innerResponse http.ResponseWriter
        statusCode    int
        contentLength int
}

func (crw *CompressedResponseWriter) ensureCompressedStream() <span class="cov8" title="1">{
        if crw.gzipWriter == nil </span><span class="cov8" title="1">{
                crw.gzipWriter = gzip.NewWriter(crw.innerResponse)
        }</span>
}

// Write writes the byes to the stream.
func (crw *CompressedResponseWriter) Write(b []byte) (int, error) <span class="cov8" title="1">{
        crw.ensureCompressedStream()
        _, err := crw.gzipWriter.Write(b)
        crw.contentLength += len(b)
        return len(b), err
}</span>

// Header returns the headers for the response.
func (crw *CompressedResponseWriter) Header() http.Header <span class="cov8" title="1">{
        return crw.innerResponse.Header()
}</span>

// WriteHeader writes a status code.
func (crw *CompressedResponseWriter) WriteHeader(code int) <span class="cov8" title="1">{
        crw.statusCode = code
        crw.innerResponse.WriteHeader(code)
}</span>

// InnerResponse returns the backing http response.
func (crw *CompressedResponseWriter) InnerResponse() http.ResponseWriter <span class="cov0" title="0">{
        return crw.innerResponse
}</span>

// StatusCode returns the status code for the request.
func (crw *CompressedResponseWriter) StatusCode() int <span class="cov8" title="1">{
        return crw.statusCode
}</span>

// ContentLength returns the content length for the request.
func (crw *CompressedResponseWriter) ContentLength() int <span class="cov8" title="1">{
        return crw.contentLength
}</span>

// Flush pushes any buffered data out to the response.
func (crw *CompressedResponseWriter) Flush() error <span class="cov0" title="0">{
        crw.ensureCompressedStream()
        return crw.gzipWriter.Flush()
}</span>

// Close closes any underlying resources.
func (crw *CompressedResponseWriter) Close() error <span class="cov8" title="1">{
        if crw.gzipWriter != nil </span><span class="cov8" title="1">{
                err := crw.gzipWriter.Close()
                crw.gzipWriter = nil
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package web

import (
        "fmt"
        "strings"
        "time"

        "github.com/blend/go-sdk/env"
        "github.com/blend/go-sdk/util"
)

// NewConfigFromEnv returns a new config from the environment.
func NewConfigFromEnv() *Config <span class="cov8" title="1">{
        var cfg Config
        if err := env.Env().ReadInto(&amp;cfg); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">return &amp;cfg</span>
}

// Config is an object used to set up a web app.
type Config struct {
        Port     int32  `json:"port" yaml:"port" env:"PORT"`
        BindAddr string `json:"bindAddr" yaml:"bindAddr" env:"BIND_ADDR"`
        BaseURL  string `json:"baseURL" yaml:"baseURL" env:"BASE_URL"`

        RedirectTrailingSlash  *bool `json:"redirectTrailingSlash" yaml:"redirectTrailingSlash"`
        HandleOptions          *bool `json:"handleOptions" yaml:"handleOptions"`
        HandleMethodNotAllowed *bool `json:"handleMethodNotAllowed" yaml:"handleMethodNotAllowed"`
        RecoverPanics          *bool `json:"recoverPanics" yaml:"recoverPanics"`

        // HSTS determines if we should issue the Strict-Transport-Security header.
        HSTS                  *bool `json:"hsts" yaml:"hsts"`
        HSTSMaxAgeSeconds     int   `json:"hstsMaxAgeSeconds" yaml:"hstsMaxAgeSeconds"`
        HSTSIncludeSubDomains *bool `json:"hstsIncludeSubdomains" yaml:"hstsIncludeSubdomains"`
        HSTSPreload           *bool `json:"hstsPreload" yaml:"hstsPreload"`

        // UseSessionCache enables or disables the in memory session cache.
        // Note: If the session cache is disabled you *must* provide a fetch handler.
        UseSessionCache *bool `json:"useSessionCache" yaml:"useSessionCache" env:"USE_SESSION_CACHE"`
        // SessionTimeout is a fixed duration to use when calculating hard or rolling deadlines.
        SessionTimeout time.Duration `json:"sessionTimeout" yaml:"sessionTimeout" env:"SESSION_TIMEOUT"`
        // SessionTimeoutIsAbsolute determines if the session timeout is a hard deadline or if it gets pushed forward with usage.
        // The default is to use a hard deadline.
        SessionTimeoutIsAbsolute *bool `json:"sessionTimeoutIsAbsolute" yaml:"sessionTimeoutIsAbsolute" env:"SESSION_TIMEOUT_ABSOLUTE"`
        // CookieHTTPS determines if we should flip the `https only` flag on issued cookies.
        CookieHTTPSOnly *bool `json:"cookieHTTPSOnly" yaml:"cookieHTTPSOnly" env:"COOKIE_HTTPS_ONLY"`
        // CookieName is the name of the cookie to issue with sessions.
        CookieName string `json:"cookieName" yaml:"cookieName" env:"COOKIE_NAME"`
        // CookiePath is the path on the cookie to issue with sessions.
        CookiePath string `json:"cookiePath" yaml:"cookiePath" env:"COOKIE_PATH"`

        // AuthSecret is a key to use to encrypt the sessionID as a second factor cookie.
        AuthSecret string `json:"authSecret" yaml:"authSecret" env:"AUTH_SECRET"`
        // SecureCookieHTTPS determines if we should flip the `https only` flag on issued secure cookies.
        SecureCookieHTTPSOnly *bool `json:"secureCookieHTTPSOnly" yaml:"secureCookieHTTPSOnly" env:"SECURE_COOKIE_HTTPS_ONLY"`
        // SecureCookieName is the name of the secure cookie to issue with sessions.
        SecureCookieName string `json:"secureCookieName" yaml:"secureCookieName" env:"SECURE_COOKIE_NAME"`

        // DefaultHeaders are included on any responses. The app ships with a set of default headers, which you can augment with this property.
        DefaultHeaders map[string]string `json:"defaultHeaders" yaml:"defaultHeaders"`

        MaxHeaderBytes    int           `json:"maxHeaderBytes" yaml:"maxHeaderBytes" env:"MAX_HEADER_BYTES"`
        ReadTimeout       time.Duration `json:"readTimeout" yaml:"readTimeout" env:"READ_HEADER_TIMEOUT"`
        ReadHeaderTimeout time.Duration `json:"readHeaderTimeout" yaml:"readHeaderTimeout" env:"READ_HEADER_TIMEOUT"`
        WriteTimeout      time.Duration `json:"writeTimeout" yaml:"writeTimeout" env:"WRITE_TIMEOUT"`
        IdleTimeout       time.Duration `json:"idleTimeout" yaml:"idleTimeout" env:"IDLE_TIMEOUT"`

        TLS   TLSConfig       `json:"tls" yaml:"tls"`
        Views ViewCacheConfig `json:"views" yaml:"views"`
}

// GetBindAddr util.Coalesces the bind addr, the port, or the default.
func (c Config) GetBindAddr(defaults ...string) string <span class="cov8" title="1">{
        if len(c.BindAddr) &gt; 0 </span><span class="cov8" title="1">{
                return c.BindAddr
        }</span>
        <span class="cov8" title="1">if c.Port &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Sprintf(":%d", c.Port)
        }</span>
        <span class="cov8" title="1">if len(defaults) &gt; 0 </span><span class="cov0" title="0">{
                return defaults[0]
        }</span>
        <span class="cov8" title="1">return DefaultBindAddr</span>
}

// GetPort returns the int32 port for a given config.
// This is useful in things like kubernetes pod templates.
// If the config .Port is unset, it will parse the .BindAddr,
// or the DefaultBindAddr for the port number.
func (c Config) GetPort(defaults ...int32) int32 <span class="cov0" title="0">{
        if c.Port &gt; 0 </span><span class="cov0" title="0">{
                return c.Port
        }</span>
        <span class="cov0" title="0">if len(defaults) &gt; 0 </span><span class="cov0" title="0">{
                return defaults[0]
        }</span>
        <span class="cov0" title="0">if len(c.BindAddr) &gt; 0 </span><span class="cov0" title="0">{
                return PortFromBindAddr(c.BindAddr)
        }</span>
        <span class="cov0" title="0">return PortFromBindAddr(DefaultBindAddr)</span>
}

// GetBaseURL gets a property.
func (c Config) GetBaseURL(defaults ...string) string <span class="cov8" title="1">{
        return util.Coalesce.String(c.BaseURL, "", defaults...)
}</span>

// GetRedirectTrailingSlash returns if we automatically redirect for a missing trailing slash.
func (c Config) GetRedirectTrailingSlash(defaults ...bool) bool <span class="cov8" title="1">{
        return util.Coalesce.Bool(c.RedirectTrailingSlash, DefaultRedirectTrailingSlash, defaults...)
}</span>

// GetHandleOptions returns if we should handle OPTIONS verb requests.
func (c Config) GetHandleOptions(defaults ...bool) bool <span class="cov8" title="1">{
        return util.Coalesce.Bool(c.HandleOptions, DefaultHandleOptions, defaults...)
}</span>

// GetHandleMethodNotAllowed returns if we should handle method not allowed results.
func (c Config) GetHandleMethodNotAllowed(defaults ...bool) bool <span class="cov8" title="1">{
        return util.Coalesce.Bool(c.HandleMethodNotAllowed, DefaultHandleMethodNotAllowed, defaults...)
}</span>

// GetRecoverPanics returns if we should recover panics or not.
func (c Config) GetRecoverPanics(defaults ...bool) bool <span class="cov8" title="1">{
        return util.Coalesce.Bool(c.RecoverPanics, DefaultRecoverPanics, defaults...)
}</span>

// GetDefaultHeaders returns the default headers from the config.
func (c Config) GetDefaultHeaders(inherited ...map[string]string) map[string]string <span class="cov8" title="1">{
        output := map[string]string{}
        if len(inherited) &gt; 0 </span><span class="cov8" title="1">{
                for _, set := range inherited </span><span class="cov8" title="1">{
                        for key, value := range set </span><span class="cov8" title="1">{
                                output[key] = value
                        }</span>
                }
        }
        <span class="cov8" title="1">for key, value := range c.DefaultHeaders </span><span class="cov0" title="0">{
                output[key] = value
        }</span>
        <span class="cov8" title="1">return output</span>
}

// ListenTLS returns if the server will directly serve requests with tls.
func (c Config) ListenTLS() bool <span class="cov8" title="1">{
        return c.TLS.HasKeyPair()
}</span>

// BaseURLIsSecureScheme returns if the base url starts with a secure scheme.
func (c Config) BaseURLIsSecureScheme() bool <span class="cov8" title="1">{
        baseURL := c.GetBaseURL()
        if len(baseURL) == 0 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov0" title="0">return strings.HasPrefix(strings.ToLower(baseURL), SchemeHTTPS) || strings.HasPrefix(strings.ToLower(baseURL), SchemeSPDY)</span>
}

// IsSecure returns if the config specifies the app will eventually be handling https requests.
func (c Config) IsSecure() bool <span class="cov8" title="1">{
        return c.ListenTLS() || c.BaseURLIsSecureScheme()
}</span>

// GetHSTS returns a property or a default.
func (c Config) GetHSTS(inherited ...bool) bool <span class="cov8" title="1">{
        return util.Coalesce.Bool(c.HSTS, DefaultHSTS &amp;&amp; c.IsSecure(), inherited...)
}</span>

// GetHSTSMaxAgeSeconds returns a property or a default.
func (c Config) GetHSTSMaxAgeSeconds(inherited ...int) int <span class="cov8" title="1">{
        return util.Coalesce.Int(c.HSTSMaxAgeSeconds, DefaultHSTSMaxAgeSeconds, inherited...)
}</span>

// GetHSTSIncludeSubDomains returns a property or a default.
func (c Config) GetHSTSIncludeSubDomains(inherited ...bool) bool <span class="cov8" title="1">{
        return util.Coalesce.Bool(c.HSTSIncludeSubDomains, DefaultHSTSIncludeSubdomains, inherited...)
}</span>

// GetHSTSPreload returns a property or a default.
func (c Config) GetHSTSPreload(inherited ...bool) bool <span class="cov8" title="1">{
        return util.Coalesce.Bool(c.HSTSPreload, DefaultHSTSPreload, inherited...)
}</span>

// GetMaxHeaderBytes returns the maximum header size in bytes or a default.
func (c Config) GetMaxHeaderBytes(defaults ...int) int <span class="cov8" title="1">{
        return util.Coalesce.Int(c.MaxHeaderBytes, DefaultMaxHeaderBytes, defaults...)
}</span>

// GetReadTimeout gets a property.
func (c Config) GetReadTimeout(defaults ...time.Duration) time.Duration <span class="cov8" title="1">{
        return util.Coalesce.Duration(c.ReadTimeout, DefaultReadTimeout, defaults...)
}</span>

// GetReadHeaderTimeout gets a property.
func (c Config) GetReadHeaderTimeout(defaults ...time.Duration) time.Duration <span class="cov8" title="1">{
        return util.Coalesce.Duration(c.ReadHeaderTimeout, DefaultReadHeaderTimeout, defaults...)
}</span>

// GetWriteTimeout gets a property.
func (c Config) GetWriteTimeout(defaults ...time.Duration) time.Duration <span class="cov8" title="1">{
        return util.Coalesce.Duration(c.WriteTimeout, DefaultWriteTimeout, defaults...)
}</span>

// GetIdleTimeout gets a property.
func (c Config) GetIdleTimeout(defaults ...time.Duration) time.Duration <span class="cov8" title="1">{
        return util.Coalesce.Duration(c.IdleTimeout, DefaultIdleTimeout, defaults...)
}</span>

// GetUseSessionCache returns a property or a default.
func (c Config) GetUseSessionCache(defaults ...bool) bool <span class="cov8" title="1">{
        return util.Coalesce.Bool(c.UseSessionCache, DefaultUseSessionCache, defaults...)
}</span>

// GetSessionTimeout returns a property or a default.
func (c Config) GetSessionTimeout(defaults ...time.Duration) time.Duration <span class="cov8" title="1">{
        return util.Coalesce.Duration(c.SessionTimeout, DefaultSessionTimeout, defaults...)
}</span>

// GetSessionTimeoutIsAbsolute returns a property or a default.
func (c Config) GetSessionTimeoutIsAbsolute(defaults ...bool) bool <span class="cov8" title="1">{
        return util.Coalesce.Bool(c.SessionTimeoutIsAbsolute, DefaultSessionTimeoutIsAbsolute, defaults...)
}</span>

// GetCookieHTTPSOnly returns a property or a default.
func (c Config) GetCookieHTTPSOnly(defaults ...bool) bool <span class="cov8" title="1">{
        return util.Coalesce.Bool(c.CookieHTTPSOnly, c.IsSecure(), defaults...)
}</span>

// GetCookieName returns a property or a default.
func (c Config) GetCookieName(defaults ...string) string <span class="cov8" title="1">{
        return util.Coalesce.String(c.CookieName, DefaultCookieName, defaults...)
}</span>

// GetCookiePath returns a property or a default.
func (c Config) GetCookiePath(defaults ...string) string <span class="cov8" title="1">{
        return util.Coalesce.String(c.CookiePath, DefaultCookiePath, defaults...)
}</span>

// GetAuthSecret returns a property or a default.
func (c Config) GetAuthSecret(defaults ...[]byte) []byte <span class="cov8" title="1">{
        decoded, err := Base64Decode(c.AuthSecret)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">return decoded</span>
}

// GetSecureCookieHTTPSOnly returns a property or a default.
func (c Config) GetSecureCookieHTTPSOnly(defaults ...bool) bool <span class="cov8" title="1">{
        return util.Coalesce.Bool(c.SecureCookieHTTPSOnly, c.GetCookieHTTPSOnly(), defaults...)
}</span>

// GetSecureCookieName returns a property or a default.
func (c Config) GetSecureCookieName(defaults ...string) string <span class="cov8" title="1">{
        return util.Coalesce.String(c.SecureCookieName, DefaultSecureCookieName, defaults...)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package web

import "time"

const (
        // PackageName is the full name of this package.
        PackageName = "github.com/blend/go-sdk/web"

        // HeaderAllow is a common header.
        HeaderAllow = "Allow"

        // RouteTokenFilepath is a special route token.
        RouteTokenFilepath = "filepath"

        // RegexpAssetCacheFiles is a common regex for parsing css, js, and html file routes.
        RegexpAssetCacheFiles = `^(.*)\.([0-9]+)\.(css|js|html|htm)$`

        // HeaderAcceptEncoding is the "Accept-Encoding" header.
        // It indicates what types of encodings the request will accept responses as.
        // It typically enables or disables compressed (gzipped) responses.
        HeaderAcceptEncoding = "Accept-Encoding"

        // HeaderSetCookie is the header that sets cookies in a response.
        HeaderSetCookie = "Set-Cookie"

        // HeaderCookie is the request cookie header.
        HeaderCookie = "Cookie"

        // HeaderDate is the "Date" header.
        // It provides a timestamp the response was generated at.
        // It is typically used by client cache control to invalidate expired items.
        HeaderDate = "Date"

        // HeaderCacheControl is the "Cache-Control" header.
        // It indicates if and how clients should cache responses.
        // Typical values for this include "no-cache", "max-age", "min-fresh", and "max-stale" variants.
        HeaderCacheControl = "Cache-Control"

        // HeaderConnection is the "Connection" header.
        // It is used to indicate if the connection should remain open by the server
        // after the final response bytes are sent.
        // This allows the connection to be re-used, helping mitigate connection negotiation
        // penalites in making requests.
        HeaderConnection = "Connection"

        // HeaderContentEncoding is the "Content-Encoding" header.
        // It is used to indicate what the response encoding is.
        // Typical values are "gzip", "deflate", "compress", "br", and "identity" indicating no compression.
        HeaderContentEncoding = "Content-Encoding"

        // HeaderContentLength is the "Content-Length" header.
        // If provided, it specifies the size of the request or response.
        HeaderContentLength = "Content-Length"

        // HeaderContentType is the "Content-Type" header.
        // It specifies the MIME-type of the request or response.
        HeaderContentType = "Content-Type"

        // HeaderServer is the "Server" header.
        // It is an informational header to tell the client what server software was used.
        HeaderServer = "Server"

        // HeaderVary is the "Vary" header.
        // It is used to indicate what fields should be used by the client as cache keys.
        HeaderVary = "Vary"

        // HeaderXServedBy is the "X-Served-By" header.
        // It is an informational header that indicates what software was used to generate the response.
        HeaderXServedBy = "X-Served-By"

        // HeaderXFrameOptions is the "X-Frame-Options" header.
        // It indicates if a browser is allowed to render the response in a &lt;frame&gt; element or not.
        HeaderXFrameOptions = "X-Frame-Options"

        // HeaderXXSSProtection is the "X-Xss-Protection" header.
        // It is a feature of internet explorer, and indicates if the browser should allow
        // requests across domain boundaries.
        HeaderXXSSProtection = "X-Xss-Protection"

        // HeaderXContentTypeOptions is the "X-Content-Type-Options" header.
        HeaderXContentTypeOptions = "X-Content-Type-Options"

        // HeaderStrictTransportSecurity is the hsts header.
        HeaderStrictTransportSecurity = "Strict-Transport-Security"

        // ContentTypeApplicationJSON is a content type for JSON responses.
        // We specify chartset=utf-8 so that clients know to use the UTF-8 string encoding.
        ContentTypeApplicationJSON = "application/json; charset=UTF-8"

        // ContentTypeHTML is a content type for html responses.
        // We specify chartset=utf-8 so that clients know to use the UTF-8 string encoding.
        ContentTypeHTML = "text/html; charset=utf-8"

        //ContentTypeXML is a content type for XML responses.
        // We specify chartset=utf-8 so that clients know to use the UTF-8 string encoding.
        ContentTypeXML = "text/xml; charset=utf-8"

        // ContentTypeText is a content type for text responses.
        // We specify chartset=utf-8 so that clients know to use the UTF-8 string encoding.
        ContentTypeText = "text/plain; charset=utf-8"

        // ConnectionKeepAlive is a value for the "Connection" header and
        // indicates the server should keep the tcp connection open
        // after the last byte of the response is sent.
        ConnectionKeepAlive = "keep-alive"

        // ContentEncodingIdentity is the identity (uncompressed) content encoding.
        ContentEncodingIdentity = "identity"
        // ContentEncodingGZIP is the gzip (compressed) content encoding.
        ContentEncodingGZIP = "gzip"
)

const (
        // SchemeHTTP is a protocol scheme.
        SchemeHTTP = "http"

        // SchemeHTTPS is a protocol scheme.
        SchemeHTTPS = "https"

        // SchemeSPDY is a protocol scheme.
        SchemeSPDY = "spdy"
)

const (
        // MethodGet is an http verb.
        MethodGet = "GET"

        // MethodPost is an http verb.
        MethodPost = "POST"

        // MethodPut is an http verb.
        MethodPut = "PUT"

        // MethodDelete is an http verb.
        MethodDelete = "DELETE"

        // MethodConnect is an http verb.
        MethodConnect = "CONNECT"

        // MethodOptions is an http verb.
        MethodOptions = "OPTIONS"
)

const (
        // HSTSMaxAgeFormat is the format string for a max age token.
        HSTSMaxAgeFormat = "max-age=%d"

        // HSTSIncludeSubDomains is a header value token.
        HSTSIncludeSubDomains = "includeSubDomains"

        // HSTSPreload is a header value token.
        HSTSPreload = "preload"
)

// Environment Variables
const (
        // EnvironmentVariableBindAddr is an env var that determines (if set) what the bind address should be.
        EnvironmentVariableBindAddr = "BIND_ADDR"

        // EnvironmentVariableHealthzBindAddr is an env var that determines (if set) what the healthz sidecar bind address should be.
        EnvironmentVariableHealthzBindAddr = "HEALTHZ_BIND_ADDR"

        // EnvironmentVariableUpgraderBindAddr is an env var that determines (if set) what the bind address should be.
        EnvironmentVariableUpgraderBindAddr = "UPGRADER_BIND_ADDR"

        // EnvironmentVariablePort is an env var that determines what the default bind address port segment returns.
        EnvironmentVariablePort = "PORT"

        // EnvironmentVariableHealthzPort is an env var that determines what the default healthz bind address port segment returns.
        EnvironmentVariableHealthzPort = "HEALTHZ_PORT"

        // EnvironmentVariableUpgraderPort is an env var that determines what the default bind address port segment returns.
        EnvironmentVariableUpgraderPort = "UPGRADER_PORT"

        // EnvironmentVariableTLSCert is an env var that contains the TLS cert.
        EnvironmentVariableTLSCert = "TLS_CERT"

        // EnvironmentVariableTLSKey is an env var that contains the TLS key.
        EnvironmentVariableTLSKey = "TLS_KEY"

        // EnvironmentVariableTLSCertFile is an env var that contains the file path to the TLS cert.
        EnvironmentVariableTLSCertFile = "TLS_CERT_FILE"

        // EnvironmentVariableTLSKeyFile is an env var that contains the file path to the TLS key.
        EnvironmentVariableTLSKeyFile = "TLS_KEY_FILE"
)

// Defaults
const (
        // DefaultBindAddr is the default bind address.
        DefaultBindAddr = ":8080"
        // DefaultHealthzBindAddr is the default healthz bind address.
        DefaultHealthzBindAddr = ":8081"
        // DefaultRedirectTrailingSlash is the default if we should redirect for missing trailing slashes.
        DefaultRedirectTrailingSlash = true
        // DefaultHandleOptions is a default.
        DefaultHandleOptions = false
        // DefaultHandleMethodNotAllowed is a default.
        DefaultHandleMethodNotAllowed = false
        // DefaultRecoverPanics returns if we should recover panics by default.
        DefaultRecoverPanics = true

        // DefaultHSTS is the default for if hsts is enabled.
        DefaultHSTS = true
        // DefaultHSTSMaxAgeSeconds is the default hsts max age seconds.
        DefaultHSTSMaxAgeSeconds = 31536000
        // DefaultHSTSIncludeSubdomains is a default.
        DefaultHSTSIncludeSubdomains = true
        // DefaultHSTSPreload is a default.
        DefaultHSTSPreload = true
        // DefaultMaxHeaderBytes is a default that is unset.
        DefaultMaxHeaderBytes = 0
        // DefaultReadTimeout is a default.
        DefaultReadTimeout = 5 * time.Second
        // DefaultReadHeaderTimeout is a default.
        DefaultReadHeaderTimeout time.Duration = 0
        // DefaultWriteTimeout is a default.
        DefaultWriteTimeout time.Duration = 0
        // DefaultIdleTimeout is a default.
        DefaultIdleTimeout time.Duration = 0
        // DefaultCookieName is the default name of the field that contains the session id.
        DefaultCookieName = "SID"
        // DefaultSecureCookieName is the default name of the field that contains the secure session id.
        DefaultSecureCookieName = "SSID"
        // DefaultCookiePath is the default cookie path.
        DefaultCookiePath = "/"
        // DefaultSessionTimeout is the default absolute timeout for a session (here implying we should use session lived sessions).
        DefaultSessionTimeout time.Duration = 0
        // DefaultUseSessionCache is the default if we should use the auth manager session cache.
        DefaultUseSessionCache = true
        // DefaultSessionTimeoutIsAbsolute is the default if we should set absolute session expiries.
        DefaultSessionTimeoutIsAbsolute = true
)

// DefaultHeaders are the default headers added by go-web.
var DefaultHeaders = map[string]string{
        HeaderServer:    PackageName,
        HeaderXServedBy: PackageName,
}

// SessionLockPolicy is a lock policy.
type SessionLockPolicy int

const (
        // SessionUnsafe is a lock-free session policy.
        SessionUnsafe SessionLockPolicy = 0

        // SessionReadLock is a lock policy that acquires a read lock on session.
        SessionReadLock SessionLockPolicy = 1

        // SessionReadWriteLock is a lock policy that acquires both a read and a write lock on session.
        SessionReadWriteLock SessionLockPolicy = 2
)

const (
        // LenSessionID is the byte length of a session id.
        LenSessionID = 64
        // LenSessionIDBase64 is the length of a session id base64 encoded.
        LenSessionIDBase64 = 88

        // ErrSessionIDEmpty is thrown if a session id is empty.
        ErrSessionIDEmpty Error = "auth session id is empty"
        // ErrSessionIDTooLong is thrown if a session id is too long.
        ErrSessionIDTooLong Error = "auth session id is too long"
        // ErrSecureSessionIDEmpty is an error that is thrown if a given secure session id is invalid.
        ErrSecureSessionIDEmpty Error = "auth secure session id is empty"
        // ErrSecureSessionIDTooLong is an error that is thrown if a given secure session id is invalid.
        ErrSecureSessionIDTooLong Error = "auth secure session id is too long"
        // ErrSecureSessionIDInvalid is an error that is thrown if a given secure session id is invalid.
        ErrSecureSessionIDInvalid Error = "auth secure session id is invalid"

        // ErrUnsetViewTemplate is an error that is thrown if a given secure session id is invalid.
        ErrUnsetViewTemplate Error = "view result template is unset"
)

// IsErrSessionInvalid returns if an error is a session invalid error.
func IsErrSessionInvalid(err error) bool <span class="cov8" title="1">{
        if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">switch err </span>{
        case ErrSessionIDEmpty,
                ErrSessionIDTooLong,
                ErrSecureSessionIDEmpty,
                ErrSecureSessionIDTooLong,
                ErrSecureSessionIDInvalid:<span class="cov8" title="1">
                return true</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package web

import (
        "context"
        "database/sql"
        "encoding/json"
        "encoding/xml"
        "fmt"
        "io/ioutil"
        "net/http"
        "strconv"
        "time"

        "strings"

        "github.com/blend/go-sdk/logger"
)

const (
        // PostBodySize is the maximum post body size we will typically consume.
        PostBodySize = int64(1 &lt;&lt; 26) //64mb

        // PostBodySizeMax is the absolute maximum file size the server can handle.
        PostBodySizeMax = int64(1 &lt;&lt; 32) //enormous.

        // StringEmpty is the empty string.
        StringEmpty = ""
)

// Request is an alias to Ctx.
// It is part of a longer term transition.
type Request = Ctx

// defaultResultProvider is used by bare ctx results, it generally
// won't stay the default for long, as it's overwritten by `App`.
var defaultResultProvider = &amp;TextResultProvider{}

// NewCtx returns a new hc context.
func NewCtx(w ResponseWriter, r *http.Request, p RouteParameters, s State) *Ctx <span class="cov8" title="1">{
        ctx := &amp;Ctx{
                response:        w,
                request:         r,
                routeParameters: p,
                state:           s,
                defaultResultProvider: defaultResultProvider,
        }

        if ctx.state == nil </span><span class="cov8" title="1">{
                ctx.state = State{}
        }</span>

        <span class="cov8" title="1">return ctx</span>
}

// Ctx is the struct that represents the context for an hc request.
type Ctx struct {
        response ResponseWriter
        request  *http.Request

        app  *App
        log  *logger.Logger
        auth *AuthManager

        postBody []byte

        view                  *ViewResultProvider
        json                  *JSONResultProvider
        xml                   *XMLResultProvider
        text                  *TextResultProvider
        defaultResultProvider ResultProvider

        state            State
        routeParameters  RouteParameters
        route            *Route
        statusCode       int
        contentLength    int
        requestStart     time.Time
        requestEnd       time.Time
        requestLogFormat string
        session          *Session

        ctx    context.Context
        cancel context.CancelFunc
}

// WithResponse sets the underlying response.
func (rc *Ctx) WithResponse(res ResponseWriter) *Ctx <span class="cov0" title="0">{
        rc.response = res
        return rc
}</span>

// Response returns the underyling response.
func (rc *Ctx) Response() ResponseWriter <span class="cov8" title="1">{
        return rc.response
}</span>

// WithRequest sets the underlying request.
func (rc *Ctx) WithRequest(req *http.Request) *Ctx <span class="cov0" title="0">{
        rc.request = req
        return rc
}</span>

// Request returns the underlying request.
func (rc *Ctx) Request() *http.Request <span class="cov8" title="1">{
        return rc.request
}</span>

// WithTx sets a transaction on the context.
func (rc *Ctx) WithTx(tx *sql.Tx, optionalKey ...string) *Ctx <span class="cov8" title="1">{
        WithTx(rc, tx, optionalKey...)
        return rc
}</span>

// WithContext sets the background context for the request.
func (rc *Ctx) WithContext(ctx context.Context) *Ctx <span class="cov0" title="0">{
        rc.ctx = ctx
        return rc
}</span>

// Background returns the background context for a request.
func (rc *Ctx) Background() context.Context <span class="cov0" title="0">{
        return rc.ctx
}</span>

// Cancel calls the cancel func if it's set.
func (rc *Ctx) Cancel() <span class="cov0" title="0">{
        if rc.cancel != nil </span><span class="cov0" title="0">{
                rc.cancel()
        }</span>
}

// WithApp sets the app reference for the ctx.
func (rc *Ctx) WithApp(app *App) *Ctx <span class="cov0" title="0">{
        rc.app = app
        return rc
}</span>

// App returns the app reference.
func (rc *Ctx) App() *App <span class="cov0" title="0">{
        return rc.app
}</span>

// WithAuth sets the request context auth.
func (rc *Ctx) WithAuth(authManager *AuthManager) *Ctx <span class="cov0" title="0">{
        rc.auth = authManager
        return rc
}</span>

// Auth returns the AuthManager for the request.
func (rc *Ctx) Auth() *AuthManager <span class="cov8" title="1">{
        return rc.auth
}</span>

// WithSession sets the session for the request.
func (rc *Ctx) WithSession(session *Session) *Ctx <span class="cov8" title="1">{
        rc.session = session
        return rc
}</span>

// Session returns the session (if any) on the request.
func (rc *Ctx) Session() *Session <span class="cov8" title="1">{
        return rc.session
}</span>

// View returns the view result provider.
func (rc *Ctx) View() *ViewResultProvider <span class="cov8" title="1">{
        return rc.view
}</span>

// JSON returns the JSON result provider.
func (rc *Ctx) JSON() *JSONResultProvider <span class="cov8" title="1">{
        return rc.json
}</span>

// XML returns the xml result provider.
func (rc *Ctx) XML() *XMLResultProvider <span class="cov0" title="0">{
        return rc.xml
}</span>

// Text returns the text result provider.
func (rc *Ctx) Text() *TextResultProvider <span class="cov8" title="1">{
        return rc.text
}</span>

// DefaultResultProvider returns the current result provider for the context. This is
// set by calling SetDefaultResultProvider or using one of the pre-built middleware
// steps that set it for you.
func (rc *Ctx) DefaultResultProvider() ResultProvider <span class="cov8" title="1">{
        return rc.defaultResultProvider
}</span>

// WithDefaultResultProvider sets the default result provider.
func (rc *Ctx) WithDefaultResultProvider(provider ResultProvider) *Ctx <span class="cov8" title="1">{
        rc.defaultResultProvider = provider
        return rc
}</span>

// State returns the full state bag.
func (rc *Ctx) State() State <span class="cov8" title="1">{
        return rc.state
}</span>

// StateValue returns an object in the state cache.
func (rc *Ctx) StateValue(key string) interface{} <span class="cov8" title="1">{
        if rc.state == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">if value, hasValue := rc.state[key]; hasValue </span><span class="cov8" title="1">{
                return value
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// WithStateValue sets the state for a key to an object.
func (rc *Ctx) WithStateValue(key string, value interface{}) *Ctx <span class="cov8" title="1">{
        if rc.state == nil </span><span class="cov0" title="0">{
                rc.state = State{}
        }</span>
        <span class="cov8" title="1">rc.state[key] = value
        return rc</span>
}

// ParamString is a shortcut for ParamString that swallows the missing value error.
func (rc *Ctx) ParamString(name string) string <span class="cov0" title="0">{
        value, _ := rc.Param(name)
        return value
}</span>

// Param returns a parameter from the request.
func (rc *Ctx) Param(name string) (string, error) <span class="cov8" title="1">{
        if rc.routeParameters != nil </span><span class="cov0" title="0">{
                routeValue := rc.routeParameters.Get(name)
                if len(routeValue) &gt; 0 </span><span class="cov0" title="0">{
                        return routeValue, nil
                }</span>
        }
        <span class="cov8" title="1">if rc.request != nil </span><span class="cov8" title="1">{
                if rc.request.URL != nil </span><span class="cov8" title="1">{
                        queryValue := rc.request.URL.Query().Get(name)
                        if len(queryValue) &gt; 0 </span><span class="cov8" title="1">{
                                return queryValue, nil
                        }</span>
                }
                <span class="cov8" title="1">if rc.request.Header != nil </span><span class="cov8" title="1">{
                        headerValue := rc.request.Header.Get(name)
                        if len(headerValue) &gt; 0 </span><span class="cov8" title="1">{
                                return headerValue, nil
                        }</span>
                }

                <span class="cov8" title="1">formValue := rc.request.FormValue(name)
                if len(formValue) &gt; 0 </span><span class="cov8" title="1">{
                        return formValue, nil
                }</span>

                <span class="cov8" title="1">cookie, cookieErr := rc.request.Cookie(name)
                if cookieErr == nil &amp;&amp; len(cookie.Value) != 0 </span><span class="cov8" title="1">{
                        return cookie.Value, nil
                }</span>
        }

        <span class="cov0" title="0">return "", newParameterMissingError(name)</span>
}

// ParamInt returns a parameter from any location as an integer.
func (rc *Ctx) ParamInt(name string) (int, error) <span class="cov0" title="0">{
        paramValue, err := rc.Param(name)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return strconv.Atoi(paramValue)</span>
}

// ParamInt64 returns a parameter from any location as an int64.
func (rc *Ctx) ParamInt64(name string) (int64, error) <span class="cov0" title="0">{
        paramValue, err := rc.Param(name)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return strconv.ParseInt(paramValue, 10, 64)</span>
}

// ParamFloat64 returns a parameter from any location as a float64.
func (rc *Ctx) ParamFloat64(name string) (float64, error) <span class="cov0" title="0">{
        paramValue, err := rc.Param(name)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return strconv.ParseFloat(paramValue, 64)</span>
}

// ParamTime returns a parameter from any location as a time with a given format.
func (rc *Ctx) ParamTime(name, format string) (time.Time, error) <span class="cov0" title="0">{
        paramValue, err := rc.Param(name)
        if err != nil </span><span class="cov0" title="0">{
                return time.Time{}, err
        }</span>
        <span class="cov0" title="0">return time.Parse(format, paramValue)</span>
}

// ParamBool returns a boolean value for a param.
func (rc *Ctx) ParamBool(name string) (bool, error) <span class="cov0" title="0">{
        paramValue, err := rc.Param(name)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">lower := strings.ToLower(paramValue)
        return lower == "true" || lower == "1" || lower == "yes", nil</span>
}

// PostBody returns the bytes in a post body.
func (rc *Ctx) PostBody() ([]byte, error) <span class="cov8" title="1">{
        var err error
        if len(rc.postBody) == 0 </span><span class="cov8" title="1">{
                if rc.request != nil &amp;&amp; rc.request.Body != nil </span><span class="cov8" title="1">{
                        defer rc.request.Body.Close()
                        rc.postBody, err = ioutil.ReadAll(rc.request.Body)
                }</span>
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">return rc.postBody, nil</span>
}

// PostBodyAsString returns the post body as a string.
func (rc *Ctx) PostBodyAsString() (string, error) <span class="cov8" title="1">{
        body, err := rc.PostBody()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return string(body), nil</span>
}

// PostBodyAsJSON reads the incoming post body (closing it) and marshals it to the target object as json.
func (rc *Ctx) PostBodyAsJSON(response interface{}) error <span class="cov8" title="1">{
        body, err := rc.PostBody()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return json.Unmarshal(body, response)</span>
}

// PostBodyAsXML reads the incoming post body (closing it) and marshals it to the target object as xml.
func (rc *Ctx) PostBodyAsXML(response interface{}) error <span class="cov0" title="0">{
        body, err := rc.PostBody()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return xml.Unmarshal(body, response)</span>
}

// PostedFiles returns any files posted
func (rc *Ctx) PostedFiles() ([]PostedFile, error) <span class="cov8" title="1">{
        var files []PostedFile

        err := rc.request.ParseMultipartForm(PostBodySize)
        if err == nil </span><span class="cov8" title="1">{
                for key := range rc.request.MultipartForm.File </span><span class="cov8" title="1">{
                        fileReader, fileHeader, err := rc.request.FormFile(key)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">bytes, err := ioutil.ReadAll(fileReader)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">files = append(files, PostedFile{Key: key, FileName: fileHeader.Filename, Contents: bytes})</span>
                }
        } else<span class="cov8" title="1"> {
                err = rc.request.ParseForm()
                if err == nil </span><span class="cov8" title="1">{
                        for key := range rc.request.PostForm </span><span class="cov0" title="0">{
                                if fileReader, fileHeader, err := rc.request.FormFile(key); err == nil &amp;&amp; fileReader != nil </span><span class="cov0" title="0">{
                                        bytes, err := ioutil.ReadAll(fileReader)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return nil, err
                                        }</span>
                                        <span class="cov0" title="0">files = append(files, PostedFile{Key: key, FileName: fileHeader.Filename, Contents: bytes})</span>
                                }
                        }
                }
        }
        <span class="cov8" title="1">return files, nil</span>
}

func newParameterMissingError(paramName string) error <span class="cov8" title="1">{
        return fmt.Errorf("`%s` parameter is missing", paramName)
}</span>

// RouteParamInt returns a route parameter as an integer.
func (rc *Ctx) RouteParamInt(key string) (int, error) <span class="cov8" title="1">{
        if value, hasKey := rc.routeParameters[key]; hasKey </span><span class="cov8" title="1">{
                return strconv.Atoi(value)
        }</span>
        <span class="cov0" title="0">return 0, newParameterMissingError(key)</span>
}

// RouteParamInt64 returns a route parameter as an integer.
func (rc *Ctx) RouteParamInt64(key string) (int64, error) <span class="cov8" title="1">{
        if value, hasKey := rc.routeParameters[key]; hasKey </span><span class="cov8" title="1">{
                return strconv.ParseInt(value, 10, 64)
        }</span>
        <span class="cov0" title="0">return 0, newParameterMissingError(key)</span>
}

// RouteParamFloat64 returns a route parameter as an float64.
func (rc *Ctx) RouteParamFloat64(key string) (float64, error) <span class="cov0" title="0">{
        if value, hasKey := rc.routeParameters[key]; hasKey </span><span class="cov0" title="0">{
                return strconv.ParseFloat(value, 64)
        }</span>
        <span class="cov0" title="0">return 0, newParameterMissingError(key)</span>
}

// RouteParam returns a string route parameter
func (rc *Ctx) RouteParam(key string) (string, error) <span class="cov8" title="1">{
        if value, hasKey := rc.routeParameters[key]; hasKey </span><span class="cov8" title="1">{
                return value, nil
        }</span>
        <span class="cov0" title="0">return StringEmpty, newParameterMissingError(key)</span>
}

// QueryParam returns a query parameter.
func (rc *Ctx) QueryParam(key string) (string, error) <span class="cov0" title="0">{
        if value := rc.request.URL.Query().Get(key); len(value) &gt; 0 </span><span class="cov0" title="0">{
                return value, nil
        }</span>
        <span class="cov0" title="0">return StringEmpty, newParameterMissingError(key)</span>
}

// QueryParamInt returns a query parameter as an integer.
func (rc *Ctx) QueryParamInt(key string) (int, error) <span class="cov0" title="0">{
        if value := rc.request.URL.Query().Get(key); len(value) &gt; 0 </span><span class="cov0" title="0">{
                return strconv.Atoi(value)
        }</span>
        <span class="cov0" title="0">return 0, newParameterMissingError(key)</span>
}

// QueryParamInt64 returns a query parameter as an int64.
func (rc *Ctx) QueryParamInt64(key string) (int64, error) <span class="cov0" title="0">{
        if value := rc.request.URL.Query().Get(key); len(value) &gt; 0 </span><span class="cov0" title="0">{
                return strconv.ParseInt(value, 10, 64)
        }</span>
        <span class="cov0" title="0">return 0, newParameterMissingError(key)</span>
}

// QueryParamFloat64 returns a query parameter as a float64.
func (rc *Ctx) QueryParamFloat64(key string) (float64, error) <span class="cov0" title="0">{
        if value := rc.request.URL.Query().Get(key); len(value) &gt; 0 </span><span class="cov0" title="0">{
                return strconv.ParseFloat(value, 64)
        }</span>
        <span class="cov0" title="0">return 0, newParameterMissingError(key)</span>
}

// QueryParamTime returns a query parameter as a time.Time.
func (rc *Ctx) QueryParamTime(key, format string) (time.Time, error) <span class="cov0" title="0">{
        if value := rc.request.URL.Query().Get(key); len(value) &gt; 0 </span><span class="cov0" title="0">{
                return time.Parse(format, value)
        }</span>
        <span class="cov0" title="0">return time.Time{}, newParameterMissingError(key)</span>
}

// HeaderParam returns a header parameter value.
func (rc *Ctx) HeaderParam(key string) (string, error) <span class="cov8" title="1">{
        if value := rc.request.Header.Get(key); len(value) &gt; 0 </span><span class="cov8" title="1">{
                return value, nil
        }</span>
        <span class="cov8" title="1">return StringEmpty, newParameterMissingError(key)</span>
}

// HeaderParamInt returns a header parameter value as an integer.
func (rc *Ctx) HeaderParamInt(key string) (int, error) <span class="cov0" title="0">{
        if value := rc.request.Header.Get(key); len(value) &gt; 0 </span><span class="cov0" title="0">{
                return strconv.Atoi(value)
        }</span>
        <span class="cov0" title="0">return 0, newParameterMissingError(key)</span>
}

// HeaderParamInt64 returns a header parameter value as an integer.
func (rc *Ctx) HeaderParamInt64(key string) (int64, error) <span class="cov0" title="0">{
        if value := rc.request.Header.Get(key); len(value) &gt; 0 </span><span class="cov0" title="0">{
                return strconv.ParseInt(value, 10, 64)
        }</span>
        <span class="cov0" title="0">return 0, newParameterMissingError(key)</span>
}

// HeaderParamFloat64 returns a header parameter value as an float64.
func (rc *Ctx) HeaderParamFloat64(key string) (float64, error) <span class="cov0" title="0">{
        if value := rc.request.Header.Get(key); len(value) &gt; 0 </span><span class="cov0" title="0">{
                return strconv.ParseFloat(value, 64)
        }</span>
        <span class="cov0" title="0">return 0, newParameterMissingError(key)</span>
}

// HeaderParamTime returns a header parameter value as an float64.
func (rc *Ctx) HeaderParamTime(key, format string) (time.Time, error) <span class="cov0" title="0">{
        if value := rc.request.Header.Get(key); len(value) &gt; 0 </span><span class="cov0" title="0">{
                return time.Parse(format, key)
        }</span>
        <span class="cov0" title="0">return time.Time{}, newParameterMissingError(key)</span>
}

// GetCookie returns a named cookie from the request.
func (rc *Ctx) GetCookie(name string) *http.Cookie <span class="cov8" title="1">{
        cookie, err := rc.request.Cookie(name)
        if err != nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return cookie</span>
}

// WriteCookie writes the cookie to the response.
func (rc *Ctx) WriteCookie(cookie *http.Cookie) <span class="cov8" title="1">{
        http.SetCookie(rc.response, cookie)
}</span>

func (rc *Ctx) getCookieDomain() string <span class="cov8" title="1">{
        if rc.app != nil &amp;&amp; rc.app.baseURL != nil </span><span class="cov0" title="0">{
                return rc.app.baseURL.Host
        }</span>
        <span class="cov8" title="1">return rc.request.Host</span>
}

// WriteNewCookie is a helper method for WriteCookie.
func (rc *Ctx) WriteNewCookie(name string, value string, expires *time.Time, path string, secure bool) <span class="cov8" title="1">{
        c := http.Cookie{
                Name:     name,
                HttpOnly: true,
                Value:    value,
                Path:     path,
                Secure:   secure,
                Domain:   rc.getCookieDomain(),
        }
        if expires != nil </span><span class="cov8" title="1">{
                c.Expires = *expires
        }</span>
        <span class="cov8" title="1">rc.WriteCookie(&amp;c)</span>
}

// ExtendCookieByDuration extends a cookie by a time duration (on the order of nanoseconds to hours).
func (rc *Ctx) ExtendCookieByDuration(name string, path string, duration time.Duration) <span class="cov0" title="0">{
        c := rc.GetCookie(name)
        if c == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">c.Path = path
        c.Domain = rc.getCookieDomain()
        c.Expires = c.Expires.Add(duration)
        rc.WriteCookie(c)</span>
}

// ExtendCookie extends a cookie by years, months or days.
func (rc *Ctx) ExtendCookie(name string, path string, years, months, days int) <span class="cov0" title="0">{
        c := rc.GetCookie(name)
        if c == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">c.Path = path
        c.Domain = rc.getCookieDomain()
        c.Expires.AddDate(years, months, days)
        rc.WriteCookie(c)</span>
}

// ExpireCookie expires a cookie.
func (rc *Ctx) ExpireCookie(name string, path string) <span class="cov8" title="1">{
        c := rc.GetCookie(name)
        if c == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">c.Path = path
        c.Value = NewSessionID()
        c.Domain = rc.getCookieDomain()
        c.Expires = time.Now().UTC().AddDate(-1, 0, 0)
        rc.WriteCookie(c)</span>
}

// --------------------------------------------------------------------------------
// Diagnostics
// --------------------------------------------------------------------------------

// Logger returns the diagnostics agent.
func (rc *Ctx) Logger() *logger.Logger <span class="cov0" title="0">{
        return rc.log
}</span>

// --------------------------------------------------------------------------------
// Basic result providers
// --------------------------------------------------------------------------------

// Raw returns a binary response body, sniffing the content type.
func (rc *Ctx) Raw(body []byte) *RawResult <span class="cov8" title="1">{
        sniffedContentType := http.DetectContentType(body)
        return rc.RawWithContentType(sniffedContentType, body)
}</span>

// RawWithContentType returns a binary response with a given content type.
func (rc *Ctx) RawWithContentType(contentType string, body []byte) *RawResult <span class="cov8" title="1">{
        return &amp;RawResult{ContentType: contentType, Body: body}
}</span>

// NoContent returns a service response.
func (rc *Ctx) NoContent() *NoContentResult <span class="cov0" title="0">{
        return &amp;NoContentResult{}
}</span>

// Static returns a static result.
func (rc *Ctx) Static(filePath string) *StaticResult <span class="cov8" title="1">{
        return NewStaticResultForFile(filePath)
}</span>

// Redirectf returns a redirect result.
func (rc *Ctx) Redirectf(format string, args ...interface{}) *RedirectResult <span class="cov0" title="0">{
        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                return &amp;RedirectResult{
                        RedirectURI: fmt.Sprintf(format, args...),
                }
        }</span>
        <span class="cov0" title="0">return &amp;RedirectResult{
                RedirectURI: format,
        }</span>
}

// RedirectWithMethodf returns a redirect result with a given method.
func (rc *Ctx) RedirectWithMethodf(method, format string, args ...interface{}) *RedirectResult <span class="cov0" title="0">{
        return &amp;RedirectResult{
                Method:      method,
                RedirectURI: fmt.Sprintf(format, args...),
        }
}</span>

// --------------------------------------------------------------------------------
// Stats Methods used for logging.
// --------------------------------------------------------------------------------

// StatusCode returns the status code for the request, this is used for logging.
func (rc *Ctx) getLoggedStatusCode() int <span class="cov0" title="0">{
        return rc.statusCode
}</span>

// SetStatusCode sets the status code for the request, this is used for logging.
func (rc *Ctx) setLoggedStatusCode(code int) <span class="cov8" title="1">{
        rc.statusCode = code
}</span>

// ContentLength returns the content length for the request, this is used for logging.
func (rc *Ctx) getLoggedContentLength() int <span class="cov0" title="0">{
        return rc.contentLength
}</span>

// SetContentLength sets the content length, this is used for logging.
func (rc *Ctx) setLoggedContentLength(length int) <span class="cov8" title="1">{
        rc.contentLength = length
}</span>

// OnRequestStart will mark the start of request timing.
func (rc *Ctx) onRequestStart() <span class="cov8" title="1">{
        rc.requestStart = time.Now().UTC()
}</span>

// Start returns the request start time.
func (rc Ctx) Start() time.Time <span class="cov0" title="0">{
        return rc.requestStart
}</span>

// OnRequestEnd will mark the end of request timing.
func (rc *Ctx) onRequestEnd() <span class="cov8" title="1">{
        rc.requestEnd = time.Now().UTC()
}</span>

// Elapsed is the time delta between start and end.
func (rc *Ctx) Elapsed() time.Duration <span class="cov8" title="1">{
        if !rc.requestEnd.IsZero() </span><span class="cov8" title="1">{
                return rc.requestEnd.Sub(rc.requestStart)
        }</span>
        <span class="cov0" title="0">return time.Now().UTC().Sub(rc.requestStart)</span>
}

// Route returns the original route match for the request.
func (rc *Ctx) Route() *Route <span class="cov8" title="1">{
        return rc.route
}</span>

// PostedFile is a file that has been posted to an hc endpoint.
type PostedFile struct {
        Key      string
        FileName string
        Contents []byte
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package web

// Error is a simple wrapper for strings to help with constant errors.
type Error string

func (e Error) Error() string <span class="cov0" title="0">{ return string(e) }</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package web

import (
        "context"
        "fmt"
        "net"
        "net/http"
        "sort"
        "strings"
        "sync"
        "time"

        "github.com/blend/go-sdk/env"
        "github.com/blend/go-sdk/exception"
        "github.com/blend/go-sdk/logger"
)

const (
        // VarzStarted is a common variable.
        VarzStarted = "startedUTC"
        // VarzRequests is a common variable.
        VarzRequests = "http_requests"
        // VarzRequests2xx is a common variable.
        VarzRequests2xx = "http_requests2xx"
        // VarzRequests3xx is a common variable.
        VarzRequests3xx = "http_requests3xx"
        // VarzRequests4xx is a common variable.
        VarzRequests4xx = "http_requests4xx"
        // VarzRequests5xx is a common variable.
        VarzRequests5xx = "http_requests5xx"
        // VarzErrors is a common variable.
        VarzErrors = "errors_total"
        // VarzFatals is a common variable.
        VarzFatals = "fatals_total"

        // ListenerHealthz is the uid of the healthz logger listeners.
        ListenerHealthz = "healthz"

        // ErrHealthzAppUnset is a common error.
        ErrHealthzAppUnset Error = "healthz app unset"
)

// NewHealthz returns a new healthz.
func NewHealthz(app *App) *Healthz <span class="cov8" title="1">{
        return &amp;Healthz{
                app:            app,
                defaultHeaders: map[string]string{},
                state:          State{},
                vars: map[string]interface{}{
                        VarzRequests:    int64(0),
                        VarzRequests2xx: int64(0),
                        VarzRequests3xx: int64(0),
                        VarzRequests4xx: int64(0),
                        VarzRequests5xx: int64(0),
                        VarzErrors:      int64(0),
                        VarzFatals:      int64(0),
                },
        }
}</span>

// NewHealthzFromEnv returns a new healthz from the env.
func NewHealthzFromEnv(app *App) *Healthz <span class="cov0" title="0">{
        return NewHealthzFromConfig(app, NewHealthzConfigFromEnv())
}</span>

// NewHealthzFromConfig returns a new healthz sidecar from a config.
func NewHealthzFromConfig(app *App, cfg *HealthzConfig) *Healthz <span class="cov0" title="0">{
        hz := NewHealthz(app)
        hz = hz.WithBindAddr(cfg.GetBindAddr())
        hz = hz.WithRecoverPanics(cfg.GetRecoverPanics())
        hz = hz.WithMaxHeaderBytes(cfg.GetMaxHeaderBytes())
        hz = hz.WithReadHeaderTimeout(cfg.GetReadHeaderTimeout())
        hz = hz.WithReadTimeout(cfg.GetReadTimeout())
        hz = hz.WithWriteTimeout(cfg.GetWriteTimeout())
        hz = hz.WithIdleTimeout(cfg.GetIdleTimeout())
        return hz
}</span>

// HealthzHost hosts an app with a healthz, starting both servers.
func HealthzHost(app *App, hz *Healthz) (err error) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        err = exception.Newf("%v", r)
                        return
                }</span>
        }()

        <span class="cov0" title="0">appQuit := make(chan struct{})
        hzQuit := make(chan struct{})
        go func() </span><span class="cov0" title="0">{
                err = app.Start()
                close(appQuit)
        }</span>()

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                err = hz.Start()
                close(hzQuit)
        }</span>()
        <span class="cov0" title="0">select </span>{
        case &lt;-appQuit:<span class="cov0" title="0">
                return</span>
        case &lt;-hzQuit:<span class="cov0" title="0">
                return</span>
        }
}

// Healthz is a sentinel / healthcheck sidecar that can run on a different
// port to the main app.
// It typically implements the following routes:
//         /healthz - overall health endpoint, 200 on healthy, 5xx on not.
//         /varz    - basic stats and metrics since start
//        /debug/vars - `pkg/expvar` output.
type Healthz struct {
        app        *App
        startedUTC time.Time
        bindAddr   string
        log        *logger.Logger

        defaultHeaders map[string]string
        server         *http.Server
        listener       *net.TCPListener

        maxHeaderBytes    int
        readTimeout       time.Duration
        readHeaderTimeout time.Duration
        writeTimeout      time.Duration
        idleTimeout       time.Duration

        state State

        varsLock sync.Mutex
        vars     map[string]interface{}

        recoverPanics bool
        err           error
}

// App returns the underlying app.
func (hz *Healthz) App() *App <span class="cov8" title="1">{
        return hz.app
}</span>

// Vars returns the underlying vars collection.
func (hz *Healthz) Vars() State <span class="cov0" title="0">{
        return hz.vars
}</span>

// Server returns the underlying server.
func (hz *Healthz) Server() *http.Server <span class="cov0" title="0">{
        return hz.server
}</span>

// Listener returns the underlying listener.
func (hz *Healthz) Listener() *net.TCPListener <span class="cov8" title="1">{
        return hz.listener
}</span>

// WithServer sets the underlying server.
func (hz *Healthz) WithServer(server *http.Server) *Healthz <span class="cov0" title="0">{
        hz.server = server
        return hz
}</span>

// WithErr sets the err that will abort app start.
func (hz *Healthz) WithErr(err error) *Healthz <span class="cov0" title="0">{
        hz.err = err
        return hz
}</span>

// Err returns any errors that are generated before app start.
func (hz *Healthz) Err() error <span class="cov0" title="0">{
        return hz.err
}</span>

// WithDefaultHeaders sets the default headers
func (hz *Healthz) WithDefaultHeaders(headers map[string]string) *Healthz <span class="cov0" title="0">{
        hz.defaultHeaders = headers
        return hz
}</span>

// WithDefaultHeader adds a default header.
func (hz *Healthz) WithDefaultHeader(key string, value string) *Healthz <span class="cov0" title="0">{
        hz.defaultHeaders[key] = value
        return hz
}</span>

// DefaultHeaders returns the default headers.
func (hz *Healthz) DefaultHeaders() map[string]string <span class="cov0" title="0">{
        return hz.defaultHeaders
}</span>

// WithState sets app state and returns a reference to the app for building apps with a fluent api.
func (hz *Healthz) WithState(key string, value interface{}) *Healthz <span class="cov0" title="0">{
        hz.state[key] = value
        return hz
}</span>

// GetState gets app state element by key.
func (hz *Healthz) GetState(key string) interface{} <span class="cov0" title="0">{
        if value, hasValue := hz.state[key]; hasValue </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// SetState sets app state.
func (hz *Healthz) SetState(key string, value interface{}) <span class="cov0" title="0">{
        hz.state[key] = value
}</span>

// State is a bag for common app state.
func (hz *Healthz) State() State <span class="cov0" title="0">{
        return hz.state
}</span>

// RecoverPanics returns if the app recovers panics.
func (hz *Healthz) RecoverPanics() bool <span class="cov0" title="0">{
        return hz.recoverPanics
}</span>

// WithRecoverPanics sets if the app should recover panics.
func (hz *Healthz) WithRecoverPanics(value bool) *Healthz <span class="cov0" title="0">{
        hz.recoverPanics = value
        return hz
}</span>

// MaxHeaderBytes returns the app max header bytes.
func (hz *Healthz) MaxHeaderBytes() int <span class="cov0" title="0">{
        return hz.maxHeaderBytes
}</span>

// WithMaxHeaderBytes sets the max header bytes value and returns a reference.
func (hz *Healthz) WithMaxHeaderBytes(byteCount int) *Healthz <span class="cov0" title="0">{
        hz.maxHeaderBytes = byteCount
        return hz
}</span>

// ReadHeaderTimeout returns the read header timeout for the server.
func (hz *Healthz) ReadHeaderTimeout() time.Duration <span class="cov0" title="0">{
        return hz.readHeaderTimeout
}</span>

// WithReadHeaderTimeout returns the read header timeout for the server.
func (hz *Healthz) WithReadHeaderTimeout(timeout time.Duration) *Healthz <span class="cov0" title="0">{
        hz.readHeaderTimeout = timeout
        return hz
}</span>

// ReadTimeout returns the read timeout for the server.
func (hz *Healthz) ReadTimeout() time.Duration <span class="cov0" title="0">{
        return hz.readTimeout
}</span>

// WithReadTimeout sets the read timeout for the server and returns a reference to the app for building apps with a fluent api.
func (hz *Healthz) WithReadTimeout(timeout time.Duration) *Healthz <span class="cov0" title="0">{
        hz.readTimeout = timeout
        return hz
}</span>

// IdleTimeout is the time before we close a connection.
func (hz *Healthz) IdleTimeout() time.Duration <span class="cov0" title="0">{
        return hz.idleTimeout
}</span>

// WithIdleTimeout sets the idle timeout.
func (hz *Healthz) WithIdleTimeout(timeout time.Duration) *Healthz <span class="cov0" title="0">{
        hz.idleTimeout = timeout
        return hz
}</span>

// WriteTimeout returns the write timeout for the server.
func (hz *Healthz) WriteTimeout() time.Duration <span class="cov0" title="0">{
        return hz.writeTimeout
}</span>

// WithWriteTimeout sets the write timeout for the server and returns a reference to the app for building apps with a fluent api.
func (hz *Healthz) WithWriteTimeout(timeout time.Duration) *Healthz <span class="cov0" title="0">{
        hz.writeTimeout = timeout
        return hz
}</span>

// WithPort sets the port for the bind address of the app, and returns a reference to the app.
func (hz *Healthz) WithPort(port int32) *Healthz <span class="cov0" title="0">{
        hz.SetPort(port)
        return hz
}</span>

// SetPort sets the port the app listens on, typically to `:%d` which indicates listen on any interface.
func (hz *Healthz) SetPort(port int32) <span class="cov0" title="0">{
        hz.bindAddr = fmt.Sprintf(":%v", port)
}</span>

// WithPortFromEnv sets the port from an environment variable, and returns a reference to the app.
func (hz *Healthz) WithPortFromEnv() *Healthz <span class="cov0" title="0">{
        hz.SetPortFromEnv()
        return hz
}</span>

// SetPortFromEnv sets the port from an environment variable, and returns a reference to the app.
func (hz *Healthz) SetPortFromEnv() <span class="cov0" title="0">{
        if env.Env().Has(EnvironmentVariablePort) </span><span class="cov0" title="0">{
                port, err := env.Env().Int32(EnvironmentVariablePort)
                if err != nil </span><span class="cov0" title="0">{
                        hz.err = err
                }</span>
                <span class="cov0" title="0">hz.bindAddr = fmt.Sprintf(":%v", port)</span>
        }
}

// BindAddr returns the address the server will bind to.
func (hz *Healthz) BindAddr() string <span class="cov8" title="1">{
        return hz.bindAddr
}</span>

// WithBindAddr sets the address the app listens on, and returns a reference to the app.
func (hz *Healthz) WithBindAddr(bindAddr string) *Healthz <span class="cov8" title="1">{
        hz.bindAddr = bindAddr
        return hz
}</span>

// WithBindAddrFromEnv sets the address the app listens on, and returns a reference to the app.
func (hz *Healthz) WithBindAddrFromEnv() *Healthz <span class="cov0" title="0">{
        hz.bindAddr = env.Env().String(EnvironmentVariableBindAddr)
        return hz
}</span>

// Logger returns the diagnostics agent for the app.
func (hz *Healthz) Logger() *logger.Logger <span class="cov0" title="0">{
        return hz.log
}</span>

// WithLogger sets the app logger agent and returns a reference to the app.
// It also sets underlying loggers in any child resources like providers and the auth manager.
func (hz *Healthz) WithLogger(log *logger.Logger) *Healthz <span class="cov8" title="1">{
        hz.log = log
        return hz
}</span>

// Start starts the server.
func (hz *Healthz) Start() (err error) <span class="cov8" title="1">{
        if hz.app == nil </span><span class="cov0" title="0">{
                err = exception.Wrap(ErrHealthzAppUnset)
                return
        }</span>
        <span class="cov8" title="1">start := time.Now()
        if hz.log != nil </span><span class="cov8" title="1">{
                hz.log.SyncTrigger(NewAppEvent(HealthzStart).WithHealthz(hz))
                defer hz.log.SyncTrigger(NewAppEvent(HealthzExit).WithHealthz(hz).WithErr(err))
        }</span>

        <span class="cov8" title="1">if hz.server == nil </span><span class="cov8" title="1">{
                hz.server = hz.CreateServer()
        }</span>
        <span class="cov8" title="1">hz.vars[VarzStarted] = time.Now().UTC()

        if hz.app.log != nil </span><span class="cov8" title="1">{
                hz.app.log.Listen(logger.WebRequest, ListenerHealthz, logger.NewWebRequestEventListener(hz.appWebRequestListener))
                hz.app.log.Listen(logger.Error, ListenerHealthz, logger.NewErrorEventListener(hz.appErrorListener))
                hz.app.log.Listen(logger.Fatal, ListenerHealthz, logger.NewErrorEventListener(hz.appErrorListener))
        }</span>

        <span class="cov8" title="1">if hz.log != nil </span><span class="cov8" title="1">{
                hz.log.SyncInfof("healthz server started, listening on %s", hz.server.Addr)
                if hz.log.Flags() != nil </span><span class="cov8" title="1">{
                        hz.log.SyncInfof("healthz server logging flags %s", hz.log.Flags().String())
                }</span>
        }

        <span class="cov8" title="1">var listener net.Listener
        listener, err = net.Listen("tcp", hz.bindAddr)
        if err != nil </span><span class="cov0" title="0">{
                err = exception.Wrap(err)
                return
        }</span>
        <span class="cov8" title="1">hz.listener = listener.(*net.TCPListener)

        if hz.log != nil </span><span class="cov8" title="1">{
                hz.log.SyncTrigger(NewAppEvent(HealthzStartComplete).WithHealthz(hz).WithElapsed(time.Since(start)))
        }</span>

        <span class="cov8" title="1">return hz.server.Serve(TCPKeepAliveListener{hz.listener})</span>
}

// Shutdown stops the server.
func (hz *Healthz) Shutdown() error <span class="cov8" title="1">{
        if hz.server == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        if hz.log != nil </span><span class="cov8" title="1">{
                hz.log.SyncInfof("healthz server shutting down")
        }</span>
        <span class="cov8" title="1">hz.server.SetKeepAlivesEnabled(false)
        return exception.Wrap(hz.server.Shutdown(ctx))</span>
}

// CreateServer returns the basic http.Server for the app.
func (hz *Healthz) CreateServer() *http.Server <span class="cov8" title="1">{
        return &amp;http.Server{
                Addr:              hz.BindAddr(),
                Handler:           hz,
                MaxHeaderBytes:    hz.maxHeaderBytes,
                ReadTimeout:       hz.readTimeout,
                ReadHeaderTimeout: hz.readHeaderTimeout,
                WriteTimeout:      hz.writeTimeout,
                IdleTimeout:       hz.idleTimeout,
        }
}</span>

// ServeHTTP makes the router implement the http.Handler interface.
func (hz *Healthz) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if hz.recoverPanics </span><span class="cov0" title="0">{
                defer hz.recover(w, r)
        }</span>

        <span class="cov8" title="1">res := NewRawResponseWriter(w)
        res.Header().Set(HeaderContentEncoding, ContentEncodingIdentity)

        route := strings.ToLower(r.URL.Path)

        start := time.Now()
        if hz.log != nil </span><span class="cov8" title="1">{
                hz.log.Trigger(logger.NewWebRequestStartEvent(r).WithState(hz.state).WithRoute(route))

                defer func() </span><span class="cov8" title="1">{
                        hz.log.Trigger(logger.NewWebRequestEvent(r).
                                WithStatusCode(res.StatusCode()).
                                WithElapsed(time.Since(start)).
                                WithContentLength(int64(res.ContentLength())).
                                WithState(hz.state))
                }</span>()
        }

        <span class="cov8" title="1">if len(hz.defaultHeaders) &gt; 0 </span><span class="cov0" title="0">{
                for key, value := range hz.defaultHeaders </span><span class="cov0" title="0">{
                        res.Header().Set(key, value)
                }</span>
        }

        <span class="cov8" title="1">switch route </span>{
        case "/healthz":<span class="cov8" title="1">
                hz.healthzHandler(res, r)</span>
        case "/varz":<span class="cov0" title="0">
                hz.varzHandler(res, r)</span>
        default:<span class="cov0" title="0">
                http.NotFound(res, r)</span>
        }

        <span class="cov8" title="1">if err := res.Close(); err != nil &amp;&amp; err != http.ErrBodyNotAllowed &amp;&amp; hz.log != nil </span><span class="cov0" title="0">{
                hz.log.Error(err)
        }</span>
}

func (hz *Healthz) recover(w http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        if rcv := recover(); rcv != nil </span><span class="cov0" title="0">{
                if hz.log != nil </span><span class="cov0" title="0">{
                        hz.log.Fatalf("%v", rcv)
                }</span>

                <span class="cov0" title="0">http.Error(w, fmt.Sprintf("%v", rcv), http.StatusInternalServerError)
                return</span>
        }
}

func (hz *Healthz) healthzHandler(w ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if hz.app.Running() </span><span class="cov8" title="1">{
                w.WriteHeader(http.StatusOK)
                w.Header().Set(HeaderContentType, ContentTypeText)
                fmt.Fprintf(w, "OK!\n")
                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusInternalServerError)
        w.Header().Set(HeaderContentType, ContentTypeText)
        fmt.Fprintf(w, "Failure!\n")
        return</span>
}

// /varz
// writes out the current stats
func (hz *Healthz) varzHandler(w ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        hz.varsLock.Lock()
        defer hz.varsLock.Unlock()

        keys := make([]string, len(hz.vars))

        var index int
        for key := range hz.vars </span><span class="cov0" title="0">{
                keys[index] = key
                index++
        }</span>

        <span class="cov0" title="0">sort.Strings(keys)

        w.WriteHeader(http.StatusOK)
        w.Header().Set(HeaderContentType, ContentTypeText)
        for _, key := range keys </span><span class="cov0" title="0">{
                fmt.Fprintf(w, "%s: %v\n", key, hz.vars[key])
        }</span>
}

func (hz *Healthz) appWebRequestListener(wre *logger.WebRequestEvent) <span class="cov0" title="0">{
        hz.varsLock.Lock()
        defer hz.varsLock.Unlock()

        hz.incrementVarUnsafe(VarzRequests)
        if wre.StatusCode() &gt;= http.StatusInternalServerError </span><span class="cov0" title="0">{
                hz.incrementVarUnsafe(VarzRequests5xx)
        }</span> else<span class="cov0" title="0"> if wre.StatusCode() &gt;= http.StatusBadRequest </span><span class="cov0" title="0">{
                hz.incrementVarUnsafe(VarzRequests4xx)
        }</span> else<span class="cov0" title="0"> if wre.StatusCode() &gt;= http.StatusMultipleChoices </span><span class="cov0" title="0">{
                hz.incrementVarUnsafe(VarzRequests3xx)
        }</span> else<span class="cov0" title="0"> {
                hz.incrementVarUnsafe(VarzRequests2xx)
        }</span>
}

func (hz *Healthz) appErrorListener(e *logger.ErrorEvent) <span class="cov0" title="0">{
        hz.varsLock.Lock()
        defer hz.varsLock.Unlock()

        switch e.Flag() </span>{
        case logger.Error:<span class="cov0" title="0">
                hz.incrementVarUnsafe(VarzErrors)
                return</span>
        case logger.Fatal:<span class="cov0" title="0">
                hz.incrementVarUnsafe(VarzFatals)
                return</span>
        }
}

func (hz *Healthz) incrementVarUnsafe(key string) <span class="cov0" title="0">{
        if value, hasValue := hz.vars[key]; hasValue </span><span class="cov0" title="0">{
                if typed, isTyped := value.(int64); isTyped </span><span class="cov0" title="0">{
                        hz.vars[key] = typed + 1
                }</span>
        } else<span class="cov0" title="0"> {
                hz.vars[key] = int64(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package web

import (
        "fmt"
        "time"

        "github.com/blend/go-sdk/env"
        "github.com/blend/go-sdk/util"
)

// NewHealthzConfigFromEnv returns a new config from the environment.
func NewHealthzConfigFromEnv() *HealthzConfig <span class="cov0" title="0">{
        var cfg HealthzConfig
        if err := env.Env().ReadInto(&amp;cfg); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return &amp;cfg</span>
}

// HealthzConfig is an object used to set up a healthz sidecar.
type HealthzConfig struct {
        Port     int32  `json:"port" yaml:"port" env:"HEALTHZ_PORT"`
        BindAddr string `json:"bindAddr" yaml:"bindAddr" env:"HEALTHZ_BIND_ADDR"`

        // DefaultHeaders are included on any responses. The app ships with a set of default headers, which you can augment with this property.
        DefaultHeaders map[string]string `json:"defaultHeaders" yaml:"defaultHeaders"`

        RecoverPanics     *bool         `json:"recoverPanics" yaml:"recoverPanics"`
        MaxHeaderBytes    int           `json:"maxHeaderBytes" yaml:"maxHeaderBytes" env:"HEALTHZ_MAX_HEADER_BYTES"`
        ReadTimeout       time.Duration `json:"readTimeout" yaml:"readTimeout" env:"HEALTHZ_READ_HEADER_TIMEOUT"`
        ReadHeaderTimeout time.Duration `json:"readHeaderTimeout" yaml:"readHeaderTimeout" env:"HEALTHZ_READ_HEADER_TIMEOUT"`
        WriteTimeout      time.Duration `json:"writeTimeout" yaml:"writeTimeout" env:"HEALTHZ_WRITE_TIMEOUT"`
        IdleTimeout       time.Duration `json:"idleTimeout" yaml:"idleTimeout" env:"HEALTHZ_IDLE_TIMEOUT"`
}

// GetBindAddr util.Coalesces the bind addr, the port, or the default.
func (hc HealthzConfig) GetBindAddr(defaults ...string) string <span class="cov0" title="0">{
        if len(hc.BindAddr) &gt; 0 </span><span class="cov0" title="0">{
                return hc.BindAddr
        }</span>
        <span class="cov0" title="0">if hc.Port &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Sprintf(":%d", hc.Port)
        }</span>
        <span class="cov0" title="0">if len(defaults) &gt; 0 </span><span class="cov0" title="0">{
                return defaults[0]
        }</span>
        <span class="cov0" title="0">return DefaultHealthzBindAddr</span>
}

// GetPort returns the int32 port for a given config.
// This is useful in things like kubernetes pod templates.
// If the config .Port is unset, it will parse the .BindAddr,
// or the DefaultBindAddr for the port number.
func (hc HealthzConfig) GetPort(defaults ...int32) int32 <span class="cov0" title="0">{
        if hc.Port &gt; 0 </span><span class="cov0" title="0">{
                return hc.Port
        }</span>
        <span class="cov0" title="0">if len(hc.BindAddr) &gt; 0 </span><span class="cov0" title="0">{
                return PortFromBindAddr(hc.BindAddr)
        }</span>
        <span class="cov0" title="0">return PortFromBindAddr(DefaultHealthzBindAddr)</span>
}

// GetRecoverPanics returns if we should recover panics or not.
func (hc HealthzConfig) GetRecoverPanics(defaults ...bool) bool <span class="cov0" title="0">{
        return util.Coalesce.Bool(hc.RecoverPanics, DefaultRecoverPanics, defaults...)
}</span>

// GetMaxHeaderBytes returns the maximum header size in bytes or a default.
func (hc HealthzConfig) GetMaxHeaderBytes(defaults ...int) int <span class="cov0" title="0">{
        return util.Coalesce.Int(hc.MaxHeaderBytes, DefaultMaxHeaderBytes, defaults...)
}</span>

// GetReadTimeout gets a property.
func (hc HealthzConfig) GetReadTimeout(defaults ...time.Duration) time.Duration <span class="cov0" title="0">{
        return util.Coalesce.Duration(hc.ReadTimeout, DefaultReadTimeout, defaults...)
}</span>

// GetReadHeaderTimeout gets a property.
func (hc HealthzConfig) GetReadHeaderTimeout(defaults ...time.Duration) time.Duration <span class="cov0" title="0">{
        return util.Coalesce.Duration(hc.ReadHeaderTimeout, DefaultReadHeaderTimeout, defaults...)
}</span>

// GetWriteTimeout gets a property.
func (hc HealthzConfig) GetWriteTimeout(defaults ...time.Duration) time.Duration <span class="cov0" title="0">{
        return util.Coalesce.Duration(hc.WriteTimeout, DefaultWriteTimeout, defaults...)
}</span>

// GetIdleTimeout gets a property.
func (hc HealthzConfig) GetIdleTimeout(defaults ...time.Duration) time.Duration <span class="cov0" title="0">{
        return util.Coalesce.Duration(hc.IdleTimeout, DefaultIdleTimeout, defaults...)
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package web

import (
        "context"
        "fmt"
        "net/http"
        "time"

        "github.com/blend/go-sdk/env"
        "github.com/blend/go-sdk/exception"
        "github.com/blend/go-sdk/logger"
)

// NewHTTPSUpgrader returns a new HTTPSUpgrader which redirects HTTP to HTTPS
func NewHTTPSUpgrader() *HTTPSUpgrader <span class="cov8" title="1">{
        return &amp;HTTPSUpgrader{}
}</span>

// NewHTTPSUpgraderFromEnv returns a new https upgrader from enviroment variables.
func NewHTTPSUpgraderFromEnv() *HTTPSUpgrader <span class="cov0" title="0">{
        return NewHTTPSUpgraderFromConfig(NewHTTPSUpgraderConfigFromEnv())
}</span>

// NewHTTPSUpgraderFromConfig creates a new https upgrader from a config.
func NewHTTPSUpgraderFromConfig(cfg *HTTPSUpgraderConfig) *HTTPSUpgrader <span class="cov0" title="0">{
        return &amp;HTTPSUpgrader{
                bindAddr:          cfg.GetBindAddr(),
                maxHeaderBytes:    cfg.GetMaxHeaderBytes(),
                readTimeout:       cfg.GetReadTimeout(),
                readHeaderTimeout: cfg.GetReadHeaderTimeout(),
                writeTimeout:      cfg.GetWriteTimeout(),
                idleTimeout:       cfg.GetIdleTimeout(),
        }
}</span>

// HTTPSUpgrader redirects HTTP to HTTPS
type HTTPSUpgrader struct {
        bindAddr string

        server *http.Server

        maxHeaderBytes    int
        readTimeout       time.Duration
        readHeaderTimeout time.Duration
        writeTimeout      time.Duration
        idleTimeout       time.Duration

        err error
        log *logger.Logger
}

// WithBindAddr sets the address the app listens on, and returns a reference to the app.
func (hu *HTTPSUpgrader) WithBindAddr(bindAddr string) *HTTPSUpgrader <span class="cov0" title="0">{
        hu.bindAddr = bindAddr
        return hu
}</span>

// WithBindAddrFromEnv sets the address the app listens on, and returns a reference to the app.
func (hu *HTTPSUpgrader) WithBindAddrFromEnv() *HTTPSUpgrader <span class="cov0" title="0">{
        hu.bindAddr = env.Env().String(EnvironmentVariableBindAddr)
        return hu
}</span>

// BindAddr returns the address the server will bind to.
func (hu *HTTPSUpgrader) BindAddr() string <span class="cov0" title="0">{
        return hu.bindAddr
}</span>

// WithPort sets the port for the bind address of the app, and returns a reference to the app.
func (hu *HTTPSUpgrader) WithPort(port int32) *HTTPSUpgrader <span class="cov0" title="0">{
        hu.SetPort(port)
        return hu
}</span>

// SetPort sets the port the app listens on, typically to `:%d` which indicates listen on any interface.
func (hu *HTTPSUpgrader) SetPort(port int32) <span class="cov0" title="0">{
        hu.bindAddr = fmt.Sprintf(":%v", port)
}</span>

// WithPortFromEnv sets the port from an environment variable, and returns a reference to the app.
func (hu *HTTPSUpgrader) WithPortFromEnv() *HTTPSUpgrader <span class="cov0" title="0">{
        hu.SetPortFromEnv()
        return hu
}</span>

// SetPortFromEnv sets the port from an environment variable, and returns a reference to the app.
func (hu *HTTPSUpgrader) SetPortFromEnv() <span class="cov0" title="0">{
        if env.Env().Has(EnvironmentVariablePort) </span><span class="cov0" title="0">{
                port, err := env.Env().Int32(EnvironmentVariablePort)
                if err != nil </span><span class="cov0" title="0">{
                        hu.err = err
                }</span>
                <span class="cov0" title="0">hu.bindAddr = fmt.Sprintf(":%v", port)</span>
        }
}

// WithLogger sets the underlying logger.
func (hu *HTTPSUpgrader) WithLogger(log *logger.Logger) *HTTPSUpgrader <span class="cov0" title="0">{
        hu.log = log
        return hu
}</span>

// Logger returns the underlying logger.
func (hu *HTTPSUpgrader) Logger() *logger.Logger <span class="cov0" title="0">{
        return hu.log
}</span>

// MaxHeaderBytes returns the app max header bytes.
func (hu *HTTPSUpgrader) MaxHeaderBytes() int <span class="cov0" title="0">{
        return hu.maxHeaderBytes
}</span>

// WithMaxHeaderBytes sets the max header bytes value and returns a reference.
func (hu *HTTPSUpgrader) WithMaxHeaderBytes(byteCount int) *HTTPSUpgrader <span class="cov0" title="0">{
        hu.maxHeaderBytes = byteCount
        return hu
}</span>

// ReadHeaderTimeout returns the read header timeout for the server.
func (hu *HTTPSUpgrader) ReadHeaderTimeout() time.Duration <span class="cov0" title="0">{
        return hu.readHeaderTimeout
}</span>

// WithReadHeaderTimeout returns the read header timeout for the server.
func (hu *HTTPSUpgrader) WithReadHeaderTimeout(timeout time.Duration) *HTTPSUpgrader <span class="cov0" title="0">{
        hu.readHeaderTimeout = timeout
        return hu
}</span>

// ReadTimeout returns the read timeout for the server.
func (hu *HTTPSUpgrader) ReadTimeout() time.Duration <span class="cov0" title="0">{
        return hu.readTimeout
}</span>

// WithReadTimeout sets the read timeout for the server and returns a reference to the app for building apps with a fluent api.
func (hu *HTTPSUpgrader) WithReadTimeout(timeout time.Duration) *HTTPSUpgrader <span class="cov0" title="0">{
        hu.readTimeout = timeout
        return hu
}</span>

// IdleTimeout is the time before we close a connection.
func (hu *HTTPSUpgrader) IdleTimeout() time.Duration <span class="cov0" title="0">{
        return hu.idleTimeout
}</span>

// WithIdleTimeout sets the idle timeout.
func (hu *HTTPSUpgrader) WithIdleTimeout(timeout time.Duration) *HTTPSUpgrader <span class="cov0" title="0">{
        hu.idleTimeout = timeout
        return hu
}</span>

// WriteTimeout returns the write timeout for the server.
func (hu *HTTPSUpgrader) WriteTimeout() time.Duration <span class="cov0" title="0">{
        return hu.writeTimeout
}</span>

// WithWriteTimeout sets the write timeout for the server and returns a reference to the app for building apps with a fluent api.
func (hu *HTTPSUpgrader) WithWriteTimeout(timeout time.Duration) *HTTPSUpgrader <span class="cov0" title="0">{
        hu.writeTimeout = timeout
        return hu
}</span>

// Server returns the basic http.Server for the app.
func (hu *HTTPSUpgrader) Server() *http.Server <span class="cov0" title="0">{
        return &amp;http.Server{
                Addr:              hu.BindAddr(),
                Handler:           hu,
                MaxHeaderBytes:    hu.maxHeaderBytes,
                ReadTimeout:       hu.readTimeout,
                ReadHeaderTimeout: hu.readHeaderTimeout,
                WriteTimeout:      hu.writeTimeout,
                IdleTimeout:       hu.idleTimeout,
        }
}</span>

// ServeHTTP redirects HTTP to HTTPS
func (hu *HTTPSUpgrader) ServeHTTP(rw http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        start := time.Now()
        response := []byte("Upgrade Required")
        if hu.log != nil </span><span class="cov0" title="0">{
                defer hu.log.Trigger(logger.NewWebRequestEvent(req).
                        WithStatusCode(http.StatusMovedPermanently).
                        WithContentLength(int64(len(response))).
                        WithContentType(ContentTypeText).
                        WithElapsed(time.Since(start)))
        }</span>

        <span class="cov8" title="1">newURL := *req.URL
        newURL.Scheme = SchemeHTTPS
        if len(newURL.Host) == 0 </span><span class="cov8" title="1">{
                newURL.Host = req.Host
        }</span>

        <span class="cov8" title="1">http.Redirect(rw, req, newURL.String(), http.StatusMovedPermanently)</span>
}

// Start starts the server and binds to the given address.
func (hu *HTTPSUpgrader) Start() error <span class="cov0" title="0">{
        return hu.StartWithServer(hu.Server())
}</span>

// StartWithServer starts the app on a custom server.
// This lets you configure things like TLS keys and
// other options.
func (hu *HTTPSUpgrader) StartWithServer(server *http.Server) (err error) <span class="cov0" title="0">{
        // early exit if we already had an issue.
        if hu.err != nil </span><span class="cov0" title="0">{
                err = hu.err
                return
        }</span>
        <span class="cov0" title="0">hu.log.SyncInfof("https upgrade server started, listening on %s", server.Addr)
        hu.server = server
        err = exception.Wrap(server.ListenAndServe())
        return</span>
}

// Shutdown stops the server.
func (hu *HTTPSUpgrader) Shutdown() error <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        hu.log.SyncInfof("https upgrade server shutting down")
        hu.server.SetKeepAlivesEnabled(false)
        return exception.Wrap(hu.server.Shutdown(ctx))
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package web

import (
        "fmt"
        "time"

        "github.com/blend/go-sdk/env"
        "github.com/blend/go-sdk/util"
)

// NewHTTPSUpgraderConfigFromEnv returns an https upgrader config populated from the environment.
func NewHTTPSUpgraderConfigFromEnv() *HTTPSUpgraderConfig <span class="cov0" title="0">{
        var cfg HTTPSUpgraderConfig
        if err := env.Env().ReadInto(&amp;cfg); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return &amp;cfg</span>
}

// HTTPSUpgraderConfig is the config for the https upgrader server.
type HTTPSUpgraderConfig struct {
        Port     int32  `json:"port" yaml:"port" env:"UPGRADE_PORT"`
        BindAddr string `json:"bindAddr" yaml:"bindAddr" env:"UPGRADE_BIND_ADDR"`

        MaxHeaderBytes    int           `json:"maxHeaderBytes" yaml:"maxHeaderBytes" env:"MAX_HEADER_BYTES"`
        ReadTimeout       time.Duration `json:"readTimeout" yaml:"readTimeout" env:"READ_HEADER_TIMEOUT"`
        ReadHeaderTimeout time.Duration `json:"readHeaderTimeout" yaml:"readHeaderTimeout" env:"READ_HEADER_TIMEOUT"`
        WriteTimeout      time.Duration `json:"writeTimeout" yaml:"writeTimeout" env:"WRITE_TIMEOUT"`
        IdleTimeout       time.Duration `json:"idleTimeout" yaml:"idleTimeout" env:"IDLE_TIMEOUT"`
}

// GetBindAddr coalesces the bind addr, the port, or the default.
func (c HTTPSUpgraderConfig) GetBindAddr(defaults ...string) string <span class="cov0" title="0">{
        if len(c.BindAddr) &gt; 0 </span><span class="cov0" title="0">{
                return c.BindAddr
        }</span>
        <span class="cov0" title="0">if c.Port &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Sprintf(":%d", c.Port)
        }</span>
        <span class="cov0" title="0">if len(defaults) &gt; 0 </span><span class="cov0" title="0">{
                return defaults[0]
        }</span>
        <span class="cov0" title="0">return DefaultBindAddr</span>
}

// GetPort returns the int32 port for a given config.
// This is useful in things like kubernetes pod templates.
// If the config .Port is unset, it will parse the .BindAddr,
// or the DefaultBindAddr for the port number.
func (c HTTPSUpgraderConfig) GetPort(defaults ...int32) int32 <span class="cov0" title="0">{
        if c.Port &gt; 0 </span><span class="cov0" title="0">{
                return c.Port
        }</span>
        <span class="cov0" title="0">if len(c.BindAddr) &gt; 0 </span><span class="cov0" title="0">{
                return PortFromBindAddr(c.BindAddr)
        }</span>
        <span class="cov0" title="0">return PortFromBindAddr(DefaultBindAddr)</span>
}

// GetMaxHeaderBytes returns the maximum header size in bytes or a default.
func (c HTTPSUpgraderConfig) GetMaxHeaderBytes(defaults ...int) int <span class="cov0" title="0">{
        return util.Coalesce.Int(c.MaxHeaderBytes, DefaultMaxHeaderBytes, defaults...)
}</span>

// GetReadTimeout gets a property.
func (c HTTPSUpgraderConfig) GetReadTimeout(defaults ...time.Duration) time.Duration <span class="cov0" title="0">{
        return util.Coalesce.Duration(c.ReadTimeout, DefaultReadTimeout, defaults...)
}</span>

// GetReadHeaderTimeout gets a property.
func (c HTTPSUpgraderConfig) GetReadHeaderTimeout(defaults ...time.Duration) time.Duration <span class="cov0" title="0">{
        return util.Coalesce.Duration(c.ReadHeaderTimeout, DefaultReadHeaderTimeout, defaults...)
}</span>

// GetWriteTimeout gets a property.
func (c HTTPSUpgraderConfig) GetWriteTimeout(defaults ...time.Duration) time.Duration <span class="cov0" title="0">{
        return util.Coalesce.Duration(c.WriteTimeout, DefaultWriteTimeout, defaults...)
}</span>

// GetIdleTimeout gets a property.
func (c HTTPSUpgraderConfig) GetIdleTimeout(defaults ...time.Duration) time.Duration <span class="cov0" title="0">{
        return util.Coalesce.Duration(c.IdleTimeout, DefaultIdleTimeout, defaults...)
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package web

// JSONResult is a json result.
type JSONResult struct {
        StatusCode int
        Response   interface{}
}

// Render renders the result
func (ar *JSONResult) Render(ctx *Ctx) error <span class="cov8" title="1">{
        return WriteJSON(ctx.Response(), ctx.Request(), ar.StatusCode, ar.Response)
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package web

import (
        "net/http"

        "github.com/blend/go-sdk/logger"
)

// NewJSONResultProvider Creates a new JSONResults object.
func NewJSONResultProvider(log *logger.Logger) *JSONResultProvider <span class="cov0" title="0">{
        return &amp;JSONResultProvider{log: log}
}</span>

// JSONResultProvider are context results for api methods.
type JSONResultProvider struct {
        log *logger.Logger
}

// NotFound returns a service response.
func (jrp *JSONResultProvider) NotFound() Result <span class="cov8" title="1">{
        return &amp;JSONResult{
                StatusCode: http.StatusNotFound,
                Response:   "Not Found",
        }
}</span>

// NotAuthorized returns a service response.
func (jrp *JSONResultProvider) NotAuthorized() Result <span class="cov0" title="0">{
        return &amp;JSONResult{
                StatusCode: http.StatusForbidden,
                Response:   "Not Authorized",
        }
}</span>

// InternalError returns a service response.
func (jrp *JSONResultProvider) InternalError(err error) Result <span class="cov0" title="0">{
        if jrp.log != nil </span><span class="cov0" title="0">{
                jrp.log.Fatal(err)
        }</span>

        <span class="cov0" title="0">return &amp;JSONResult{
                StatusCode: http.StatusInternalServerError,
                Response:   err.Error(),
        }</span>
}

// BadRequest returns a service response.
func (jrp *JSONResultProvider) BadRequest(err error) Result <span class="cov0" title="0">{
        if err != nil </span><span class="cov0" title="0">{
                return &amp;JSONResult{
                        StatusCode: http.StatusBadRequest,
                        Response:   err,
                }
        }</span>
        <span class="cov0" title="0">return &amp;JSONResult{
                StatusCode: http.StatusBadRequest,
                Response:   "Bad Request",
        }</span>
}

// OK returns a service response.
func (jrp *JSONResultProvider) OK() Result <span class="cov0" title="0">{
        return &amp;JSONResult{
                StatusCode: http.StatusOK,
                Response:   "OK!",
        }
}</span>

// Result returns a json response.
func (jrp *JSONResultProvider) Result(response interface{}) Result <span class="cov8" title="1">{
        return &amp;JSONResult{
                StatusCode: http.StatusOK,
                Response:   response,
        }
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package web

import (
        "context"
        "time"
)

// Cancel injects the context for a given action with a cancel func.
func Cancel(action Action) Action <span class="cov0" title="0">{
        return func(ctx *Ctx) Result </span><span class="cov0" title="0">{
                ctx.ctx, ctx.cancel = context.WithCancel(context.Background())
                return action(ctx)
        }</span>
}

// Timeout injects the context for a given action with a timeout context.
func Timeout(d time.Duration) Middleware <span class="cov0" title="0">{
        return func(action Action) Action </span><span class="cov0" title="0">{
                return func(ctx *Ctx) Result </span><span class="cov0" title="0">{
                        ctx.ctx, ctx.cancel = context.WithTimeout(context.Background(), d)
                        return action(ctx)
                }</span>
        }
}

// ViewProviderAsDefault sets the context.DefaultResultProvider() equal to context.View().
func ViewProviderAsDefault(action Action) Action <span class="cov8" title="1">{
        return func(ctx *Ctx) Result </span><span class="cov8" title="1">{
                return action(ctx.WithDefaultResultProvider(ctx.View()))
        }</span>
}

// JSONProviderAsDefault sets the context.DefaultResultProvider() equal to context.JSON().
func JSONProviderAsDefault(action Action) Action <span class="cov8" title="1">{
        return func(ctx *Ctx) Result </span><span class="cov8" title="1">{
                return action(ctx.WithDefaultResultProvider(ctx.JSON()))
        }</span>
}

// XMLProviderAsDefault sets the context.DefaultResultProvider() equal to context.XML().
func XMLProviderAsDefault(action Action) Action <span class="cov0" title="0">{
        return func(ctx *Ctx) Result </span><span class="cov0" title="0">{
                return action(ctx.WithDefaultResultProvider(ctx.XML()))
        }</span>
}

// TextProviderAsDefault sets the context.DefaultResultProvider() equal to context.Text().
func TextProviderAsDefault(action Action) Action <span class="cov0" title="0">{
        return func(ctx *Ctx) Result </span><span class="cov0" title="0">{
                return action(ctx.WithDefaultResultProvider(ctx.Text()))
        }</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package web

import (
        "bytes"
        "database/sql"
        "encoding/json"
        "encoding/xml"
        "fmt"
        "io"
        "io/ioutil"
        "mime/multipart"
        "net/http"
        "net/url"
        "strings"
        "time"

        "github.com/blend/go-sdk/exception"
)

// NewMockRequestBuilder returns a new mock request builder for a given app.
func NewMockRequestBuilder(app *App) *MockRequestBuilder <span class="cov8" title="1">{
        return &amp;MockRequestBuilder{
                app:         app,
                verb:        "GET",
                queryString: url.Values{},
                formValues:  url.Values{},
                headers:     http.Header{},
                state:       State{},
        }
}</span>

// MockRequestBuilder facilitates creating mock requests.
type MockRequestBuilder struct {
        app *App

        verb        string
        path        string
        queryString url.Values
        formValues  url.Values
        headers     http.Header
        cookies     []*http.Cookie
        postBody    []byte

        postedFiles map[string]PostedFile

        err error

        state State
}

// WithErr sets the error if it is unset.
func (mrb *MockRequestBuilder) WithErr(err error) *MockRequestBuilder <span class="cov0" title="0">{
        if err != nil </span><span class="cov0" title="0">{
                mrb.err = err
        }</span>
        <span class="cov0" title="0">return mrb</span>
}

// Err rerturns an underlying error
func (mrb *MockRequestBuilder) Err() error <span class="cov0" title="0">{
        return mrb.err
}</span>

// Get is a shortcut for WithVerb("GET") WithPathf(pathFormat, args...)
func (mrb *MockRequestBuilder) Get(pathFormat string, args ...interface{}) *MockRequestBuilder <span class="cov8" title="1">{
        return mrb.WithVerb("GET").WithPathf(pathFormat, args...)
}</span>

// Post is a shortcut for WithVerb("POST") WithPathf(pathFormat, args...)
func (mrb *MockRequestBuilder) Post(pathFormat string, args ...interface{}) *MockRequestBuilder <span class="cov0" title="0">{
        return mrb.WithVerb("POST").WithPathf(pathFormat, args...)
}</span>

// Put is a shortcut for WithVerb("PUT") WithPathf(pathFormat, args...)
func (mrb *MockRequestBuilder) Put(pathFormat string, args ...interface{}) *MockRequestBuilder <span class="cov0" title="0">{
        return mrb.WithVerb("PUT").WithPathf(pathFormat, args...)
}</span>

// Patch is a shortcut for WithVerb("PATCH") WithPathf(pathFormat, args...)
func (mrb *MockRequestBuilder) Patch(pathFormat string, args ...interface{}) *MockRequestBuilder <span class="cov0" title="0">{
        return mrb.WithVerb("PATCH").WithPathf(pathFormat, args...)
}</span>

// Delete is a shortcut for WithVerb("DELETE") WithPathf(pathFormat, args...)
func (mrb *MockRequestBuilder) Delete(pathFormat string, args ...interface{}) *MockRequestBuilder <span class="cov0" title="0">{
        return mrb.WithVerb("DELETE").WithPathf(pathFormat, args...)
}</span>

// WithVerb sets the verb for the request.
func (mrb *MockRequestBuilder) WithVerb(verb string) *MockRequestBuilder <span class="cov8" title="1">{
        mrb.verb = strings.ToUpper(verb)
        return mrb
}</span>

// WithPathf sets the path for the request.
func (mrb *MockRequestBuilder) WithPathf(pathFormat string, args ...interface{}) *MockRequestBuilder <span class="cov8" title="1">{
        mrb.path = fmt.Sprintf(pathFormat, args...)

        // url.Parse always includes the '/' path prefix.
        if !strings.HasPrefix(mrb.path, "/") </span><span class="cov0" title="0">{
                mrb.path = fmt.Sprintf("/%s", mrb.path)
        }</span>

        <span class="cov8" title="1">return mrb</span>
}

// WithQueryString adds a querystring param for the request.
func (mrb *MockRequestBuilder) WithQueryString(key, value string) *MockRequestBuilder <span class="cov8" title="1">{
        mrb.queryString.Add(key, value)
        return mrb
}</span>

// WithFormValue adds a form value for the request.
func (mrb *MockRequestBuilder) WithFormValue(key, value string) *MockRequestBuilder <span class="cov8" title="1">{
        mrb.formValues.Add(key, value)
        return mrb
}</span>

// WithHeader adds a header for the request.
func (mrb *MockRequestBuilder) WithHeader(key, value string) *MockRequestBuilder <span class="cov8" title="1">{
        mrb.headers.Add(key, value)
        return mrb
}</span>

// WithCookie adds a cookie for the request.
func (mrb *MockRequestBuilder) WithCookie(cookie *http.Cookie) *MockRequestBuilder <span class="cov8" title="1">{
        mrb.cookies = append(mrb.cookies, cookie)
        return mrb
}</span>

// WithCookieValue adds a basic name+value cookie for the request.
func (mrb *MockRequestBuilder) WithCookieValue(name, value string) *MockRequestBuilder <span class="cov8" title="1">{
        mrb.cookies = append(mrb.cookies, NewBasicCookie(name, value))
        return mrb
}</span>

// WithPostBody sets the post body for the request.
func (mrb *MockRequestBuilder) WithPostBody(postBody []byte) *MockRequestBuilder <span class="cov8" title="1">{
        mrb.postBody = postBody
        return mrb
}</span>

// WithPostBodyAsJSON sets the post body for the request by serializing an object to JSON.
func (mrb *MockRequestBuilder) WithPostBodyAsJSON(object interface{}) *MockRequestBuilder <span class="cov0" title="0">{
        bytes, _ := json.Marshal(object)
        mrb.postBody = bytes
        return mrb
}</span>

// WithPostedFile includes a file as a post parameter.
func (mrb *MockRequestBuilder) WithPostedFile(postedFile PostedFile) *MockRequestBuilder <span class="cov8" title="1">{
        if mrb.postedFiles == nil </span><span class="cov8" title="1">{
                mrb.postedFiles = map[string]PostedFile{}
        }</span>
        <span class="cov8" title="1">mrb.postedFiles[postedFile.Key] = postedFile
        return mrb</span>
}

// WithTx sets the transaction for the request.
func (mrb *MockRequestBuilder) WithTx(tx *sql.Tx, keys ...string) *MockRequestBuilder <span class="cov8" title="1">{
        WithTx(mrb, tx, keys...)
        return mrb
}</span>

// State returns the underlying state.
func (mrb *MockRequestBuilder) State() State <span class="cov8" title="1">{
        return mrb.state
}</span>

// WithStateValue sets the state for a key to an object.
func (mrb *MockRequestBuilder) WithStateValue(key string, value interface{}) *MockRequestBuilder <span class="cov8" title="1">{
        if mrb.state == nil </span><span class="cov0" title="0">{
                mrb.state = State{}
        }</span>
        <span class="cov8" title="1">mrb.state[key] = value
        return mrb</span>
}

// GetStateValue returns an object in the state cache.
func (mrb *MockRequestBuilder) GetStateValue(key string) interface{} <span class="cov0" title="0">{
        if mrb.state == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if item, hasItem := mrb.state[key]; hasItem </span><span class="cov0" title="0">{
                return item
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Request returns the mock request builder settings as an http.Request.
func (mrb *MockRequestBuilder) Request() (*http.Request, error) <span class="cov8" title="1">{
        req := &amp;http.Request{}

        reqURL, err := url.Parse(fmt.Sprintf("http://localhost%s", mrb.path))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">reqURL.RawQuery = mrb.queryString.Encode()
        req.Method = mrb.verb
        req.URL = reqURL
        req.RequestURI = reqURL.String()
        req.Form = mrb.formValues
        req.Header = http.Header{}

        for key, values := range mrb.headers </span><span class="cov8" title="1">{
                for _, value := range values </span><span class="cov8" title="1">{
                        req.Header.Add(key, value)
                }</span>
        }

        <span class="cov8" title="1">for _, cookie := range mrb.cookies </span><span class="cov8" title="1">{
                req.AddCookie(cookie)
        }</span>

        <span class="cov8" title="1">if len(mrb.postedFiles) &gt; 0 </span><span class="cov8" title="1">{
                b := bytes.NewBuffer(nil)
                w := multipart.NewWriter(b)
                for _, file := range mrb.postedFiles </span><span class="cov8" title="1">{
                        fw, err := w.CreateFormFile(file.Key, file.FileName)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">_, err = io.Copy(fw, bytes.NewBuffer(file.Contents))
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }
                // Don't forget to set the content type, this will contain the boundary.
                <span class="cov8" title="1">req.Header.Set("Content-Type", w.FormDataContentType())

                err = w.Close()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">req.Body = ioutil.NopCloser(b)</span>
        } else<span class="cov8" title="1"> if len(mrb.postBody) &gt; 0 </span><span class="cov8" title="1">{
                req.Body = ioutil.NopCloser(bytes.NewBuffer(mrb.postBody))
        }</span>

        <span class="cov8" title="1">return req, nil</span>
}

// LookupRoute returns the corresponding route for the mocked request.
func (mrb *MockRequestBuilder) LookupRoute() (route *Route, params RouteParameters) <span class="cov8" title="1">{
        var tsr bool
        path := mrb.path
        route, params, tsr = mrb.app.Lookup(mrb.verb, path)
        if tsr </span><span class="cov0" title="0">{
                path = path + "/"
                route, params, tsr = mrb.app.Lookup(mrb.verb, path)
        }</span>
        <span class="cov8" title="1">return</span>
}

// CreateCtx returns the mock request as a request context.
func (mrb *MockRequestBuilder) CreateCtx(p RouteParameters) (*Ctx, error) <span class="cov8" title="1">{
        r, err := mrb.Request()

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">w := NewMockResponseWriter(bytes.NewBuffer(nil))
        if mrb.app == nil </span><span class="cov8" title="1">{
                return NewCtx(w, r, p, mrb.state), nil
        }</span>

        <span class="cov8" title="1">var rc *Ctx
        route, _ := mrb.LookupRoute()
        if route != nil </span><span class="cov0" title="0">{
                rc = mrb.app.createCtx(w, r, route, p, mrb.state)
        }</span> else<span class="cov8" title="1"> {
                rc = mrb.app.createCtx(w, r, nil, nil, mrb.state)
        }</span>

        <span class="cov8" title="1">return rc, nil</span>
}

// Response runs the mock request.
func (mrb *MockRequestBuilder) Response() (res *http.Response, err error) <span class="cov8" title="1">{
        if mrb.err != nil </span><span class="cov0" title="0">{
                err = mrb.err
                return
        }</span>

        <span class="cov8" title="1">var req *http.Request
        req, err = mrb.Request()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">var route *Route
        var params RouteParameters
        route, params = mrb.LookupRoute()
        if route == nil &amp;&amp; mrb.app.notFoundHandler != nil </span><span class="cov8" title="1">{
                res = mrb.runHandler(mrb.app.notFoundHandler, req, route, params)
                return
        }</span> else<span class="cov8" title="1"> if route == nil </span><span class="cov0" title="0">{
                err = exception.Newf("No route registered for %s %s", mrb.verb, mrb.path)
                return
        }</span>

        <span class="cov8" title="1">res = mrb.runHandler(route.Handler, req, route, params)
        return</span>
}

func (mrb *MockRequestBuilder) runHandler(handler Handler, req *http.Request, route *Route, params RouteParameters) (res *http.Response) <span class="cov8" title="1">{
        if mrb.app != nil &amp;&amp; mrb.app.recoverPanics &amp;&amp; mrb.app.panicAction != nil </span><span class="cov8" title="1">{
                defer func() </span><span class="cov8" title="1">{
                        if r := recover(); r != nil </span><span class="cov8" title="1">{
                                buffer := bytes.NewBuffer(nil)
                                w := NewMockResponseWriter(buffer)
                                mrb.app.handlePanic(w, req, r)
                                res = mrb.createResponse(buffer, w)
                        }</span>
                }()
        }

        <span class="cov8" title="1">buffer := bytes.NewBuffer(nil)
        w := NewMockResponseWriter(buffer)
        handler(w, req, route, params, mrb.state)
        res = mrb.createResponse(buffer, w)
        return res</span>
}

func (mrb *MockRequestBuilder) createResponse(buffer *bytes.Buffer, w ResponseWriter) *http.Response <span class="cov8" title="1">{
        res := &amp;http.Response{
                Body:          ioutil.NopCloser(bytes.NewBuffer(buffer.Bytes())),
                ContentLength: int64(w.ContentLength()),
                Header:        http.Header{},
                StatusCode:    w.StatusCode(),
                Proto:         "http",
                ProtoMajor:    1,
                ProtoMinor:    1,
        }
        for key, values := range w.Header() </span><span class="cov8" title="1">{
                for _, value := range values </span><span class="cov8" title="1">{
                        res.Header.Add(key, value)
                }</span>
        }
        <span class="cov8" title="1">return res</span>
}

// JSON executes the mock request and reads the response to the given object as json.
func (mrb *MockRequestBuilder) JSON(object interface{}) error <span class="cov8" title="1">{
        res, err := mrb.Response()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer res.Body.Close()
        contents, err := ioutil.ReadAll(res.Body)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return json.Unmarshal(contents, object)</span>
}

// JSONWithMeta executes the mock request and reads the response to the given object as json.
func (mrb *MockRequestBuilder) JSONWithMeta(object interface{}) (*ResponseMeta, error) <span class="cov0" title="0">{
        res, err := mrb.Response()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer res.Body.Close()
        contents, err := ioutil.ReadAll(res.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return NewResponseMeta(res), json.Unmarshal(contents, object)</span>
}

// XML executes the mock request and reads the response to the given object as json.
func (mrb *MockRequestBuilder) XML(object interface{}) error <span class="cov0" title="0">{
        res, err := mrb.Response()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer res.Body.Close()
        contents, err := ioutil.ReadAll(res.Body)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return xml.Unmarshal(contents, object)</span>
}

// XMLWithMeta executes the mock request and reads the response to the given object as json.
func (mrb *MockRequestBuilder) XMLWithMeta(object interface{}) (*ResponseMeta, error) <span class="cov0" title="0">{
        res, err := mrb.Response()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer res.Body.Close()
        contents, err := ioutil.ReadAll(res.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return NewResponseMeta(res), xml.Unmarshal(contents, object)</span>
}

// Bytes returns the response as bytes.
func (mrb *MockRequestBuilder) Bytes() ([]byte, error) <span class="cov8" title="1">{
        res, err := mrb.Response()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer res.Body.Close()
        return ioutil.ReadAll(res.Body)</span>
}

// BytesWithMeta returns the response as bytes with meta information.
func (mrb *MockRequestBuilder) BytesWithMeta() ([]byte, *ResponseMeta, error) <span class="cov8" title="1">{
        res, err := mrb.Response()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov8" title="1">defer res.Body.Close()
        contents, err := ioutil.ReadAll(res.Body)
        return contents, NewResponseMeta(res), err</span>
}

// Execute just runs the request.
// It internally calls `Bytes()` which fully consumes the response.
func (mrb *MockRequestBuilder) Execute() error <span class="cov8" title="1">{
        _, err := mrb.Bytes()
        return err
}</span>

// ExecuteWithMeta returns basic metadata for a response.
func (mrb *MockRequestBuilder) ExecuteWithMeta() (*ResponseMeta, error) <span class="cov8" title="1">{
        res, err := mrb.Response()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if res.Body != nil </span><span class="cov8" title="1">{
                defer res.Body.Close()
                _, err = ioutil.ReadAll(res.Body)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">return NewResponseMeta(res), nil</span>
}

// NewRequestMeta returns a new meta object for a request.
func NewRequestMeta(req *http.Request) *RequestMeta <span class="cov0" title="0">{
        return &amp;RequestMeta{
                Verb:    req.Method,
                URL:     req.URL,
                Headers: req.Header,
        }
}</span>

// NewRequestMetaWithBody returns a new meta object for a request and reads the body.
func NewRequestMetaWithBody(req *http.Request) (*RequestMeta, error) <span class="cov0" title="0">{
        body, err := ioutil.ReadAll(req.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer req.Body.Close()
        return &amp;RequestMeta{
                Verb:    req.Method,
                URL:     req.URL,
                Headers: req.Header,
                Body:    body,
        }, nil</span>
}

// RequestMeta is the metadata for a request.
type RequestMeta struct {
        StartTime time.Time
        Verb      string
        URL       *url.URL
        Headers   http.Header
        Body      []byte
}

// NewResponseMeta creates a new ResponseMeta.
func NewResponseMeta(res *http.Response) *ResponseMeta <span class="cov8" title="1">{
        return &amp;ResponseMeta{
                StatusCode:    res.StatusCode,
                Headers:       res.Header,
                ContentLength: res.ContentLength,
        }
}</span>

// ResponseMeta is a metadata response struct
type ResponseMeta struct {
        StatusCode    int
        ContentLength int64
        Headers       http.Header
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package web

import (
        "bytes"
        "io"
        "net/http"
)

// NewMockResponseWriter returns a mocked response writer.
func NewMockResponseWriter(buffer io.Writer) *MockResponseWriter <span class="cov8" title="1">{
        return &amp;MockResponseWriter{
                innerWriter: buffer,
                contents:    bytes.NewBuffer([]byte{}),
                headers:     http.Header{},
        }
}</span>

// MockResponseWriter is an object that satisfies response writer but uses an internal buffer.
type MockResponseWriter struct {
        innerWriter   io.Writer
        contents      *bytes.Buffer
        statusCode    int
        contentLength int
        headers       http.Header
}

// Write writes data and adds to ContentLength.
func (res *MockResponseWriter) Write(buffer []byte) (int, error) <span class="cov8" title="1">{
        bytesWritten, err := res.innerWriter.Write(buffer)
        res.contentLength += bytesWritten
        defer func() </span><span class="cov8" title="1">{
                res.contents.Write(buffer)
        }</span>()
        <span class="cov8" title="1">return bytesWritten, err</span>
}

// Header returns the response headers.
func (res *MockResponseWriter) Header() http.Header <span class="cov8" title="1">{
        return res.headers
}</span>

// WriteHeader sets the status code.
func (res *MockResponseWriter) WriteHeader(statusCode int) <span class="cov8" title="1">{
        res.statusCode = statusCode
}</span>

// InnerResponse returns the backing httpresponse writer.
func (res *MockResponseWriter) InnerResponse() http.ResponseWriter <span class="cov0" title="0">{
        return res
}</span>

// StatusCode returns the status code.
func (res *MockResponseWriter) StatusCode() int <span class="cov8" title="1">{
        return res.statusCode
}</span>

// ContentLength returns the content length.
func (res *MockResponseWriter) ContentLength() int <span class="cov8" title="1">{
        return res.contentLength
}</span>

// Bytes returns the raw response.
func (res *MockResponseWriter) Bytes() []byte <span class="cov0" title="0">{
        return res.contents.Bytes()
}</span>

// Flush is a no-op.
func (res *MockResponseWriter) Flush() error <span class="cov0" title="0">{
        return nil
}</span>

// Close is a no-op.
func (res *MockResponseWriter) Close() error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package web

import "net/http"

// NoContentResult returns a no content response.
type NoContentResult struct{}

// Render renders a static result.
func (ncr *NoContentResult) Render(ctx *Ctx) error <span class="cov0" title="0">{
        ctx.Response().WriteHeader(http.StatusNoContent)
        _, err := ctx.Response().Write([]byte{})
        return err
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package web

import (
        "github.com/blend/go-sdk/logger"
)

var noContent = &amp;NoContentResult{}

// NoContentResultProvider is a provider that returns `http.StatusNoContent`
// for all responses.
type NoContentResultProvider struct {
        log *logger.Logger
}

// NotFound returns a no content response.
func (ncr *NoContentResultProvider) NotFound() Result <span class="cov0" title="0">{
        return noContent
}</span>

// NotAuthorized returns a no content response.
func (ncr *NoContentResultProvider) NotAuthorized() Result <span class="cov0" title="0">{
        return noContent
}</span>

// InternalError returns a no content response.
func (ncr *NoContentResultProvider) InternalError(err error) Result <span class="cov0" title="0">{
        if ncr.log != nil </span><span class="cov0" title="0">{
                ncr.log.Fatal(err)
        }</span>
        <span class="cov0" title="0">return noContent</span>
}

// BadRequest returns a no content response.
func (ncr *NoContentResultProvider) BadRequest(err error) Result <span class="cov0" title="0">{
        return noContent
}</span>

// Result returns a no content response.
func (ncr *NoContentResultProvider) Result(response interface{}) Result <span class="cov0" title="0">{
        return noContent
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package web

import (
        "net/http"
)

// NewRawResponseWriter creates a new uncompressed response writer.
func NewRawResponseWriter(w http.ResponseWriter) *RawResponseWriter <span class="cov8" title="1">{
        return &amp;RawResponseWriter{
                innerResponse: w,
        }
}</span>

// RawResponseWriter  a better response writer
type RawResponseWriter struct {
        innerResponse http.ResponseWriter
        contentLength int
        statusCode    int
}

// Write writes the data to the response.
func (rw *RawResponseWriter) Write(b []byte) (int, error) <span class="cov8" title="1">{
        written, err := rw.innerResponse.Write(b)
        rw.contentLength += written
        return written, err
}</span>

// Header accesses the response header collection.
func (rw *RawResponseWriter) Header() http.Header <span class="cov8" title="1">{
        return rw.innerResponse.Header()
}</span>

// WriteHeader is actually a terrible name and this writes the status code.
func (rw *RawResponseWriter) WriteHeader(code int) <span class="cov8" title="1">{
        rw.statusCode = code
        rw.innerResponse.WriteHeader(code)
}</span>

// InnerResponse returns the backing writer.
func (rw *RawResponseWriter) InnerResponse() http.ResponseWriter <span class="cov0" title="0">{
        return rw.innerResponse
}</span>

// StatusCode returns the status code.
func (rw *RawResponseWriter) StatusCode() int <span class="cov8" title="1">{
        return rw.statusCode
}</span>

// ContentLength returns the content length
func (rw *RawResponseWriter) ContentLength() int <span class="cov8" title="1">{
        return rw.contentLength
}</span>

// Close disposes of the response writer.
func (rw *RawResponseWriter) Close() error <span class="cov8" title="1">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package web

import "net/http"

// RawResult is for when you just want to dump bytes.
type RawResult struct {
        StatusCode  int
        ContentType string
        Body        []byte
}

// Render renders the result.
func (rr *RawResult) Render(ctx *Ctx) error <span class="cov8" title="1">{
        if len(rr.ContentType) != 0 </span><span class="cov8" title="1">{
                ctx.Response().Header().Set("Content-Type", rr.ContentType)
        }</span>
        <span class="cov8" title="1">if rr.StatusCode == 0 </span><span class="cov8" title="1">{
                ctx.Response().WriteHeader(http.StatusOK)
        }</span> else<span class="cov8" title="1"> {
                ctx.Response().WriteHeader(rr.StatusCode)
        }</span>
        <span class="cov8" title="1">_, err := ctx.Response().Write(rr.Body)
        return err</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package web

import "net/http"

// RedirectResult is a result that should cause the browser to redirect.
type RedirectResult struct {
        Method      string `json:"redirect_method"`
        RedirectURI string `json:"redirect_uri"`
}

// Render writes the result to the response.
func (rr *RedirectResult) Render(ctx *Ctx) error <span class="cov0" title="0">{
        if len(rr.Method) &gt; 0 </span><span class="cov0" title="0">{
                ctx.Request().Method = rr.Method
                http.Redirect(ctx.Response(), ctx.Request(), rr.RedirectURI, http.StatusFound)
        }</span> else<span class="cov0" title="0"> {
                http.Redirect(ctx.Response(), ctx.Request(), rr.RedirectURI, http.StatusTemporaryRedirect)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package web

import "regexp"

// RewriteAction is an action for a rewrite rule.
type RewriteAction func(filePath string, matchedPieces ...string) string

// RewriteRule is a rule for re-writing incoming static urls.
type RewriteRule struct {
        MatchExpression string
        expr            *regexp.Regexp
        Action          RewriteAction
}

// Apply runs the filter, returning a bool if it matched, and the resulting path.
func (rr RewriteRule) Apply(filePath string) (bool, string) <span class="cov8" title="1">{
        if rr.expr.MatchString(filePath) </span><span class="cov8" title="1">{
                pieces := extractSubMatches(rr.expr, filePath)
                return true, rr.Action(filePath, pieces...)
        }</span>

        <span class="cov8" title="1">return false, filePath</span>
}

// ExtractSubMatches returns sub matches for an expr because go's regexp library is weird.
func extractSubMatches(re *regexp.Regexp, corpus string) []string <span class="cov8" title="1">{
        allResults := re.FindAllStringSubmatch(corpus, -1)
        results := []string{}
        for _, resultSet := range allResults </span><span class="cov8" title="1">{
                for _, result := range resultSet </span><span class="cov8" title="1">{
                        results = append(results, result)
                }</span>
        }

        <span class="cov8" title="1">return results</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package web

import (
        "fmt"
        "net/http"
)

// Handler is the most basic route handler.
type Handler func(http.ResponseWriter, *http.Request, *Route, RouteParameters, State)

// WrapHandler wraps an http.Handler as a Handler.
func WrapHandler(handler http.Handler) Handler <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request, _ *Route, _ RouteParameters, _ State) </span><span class="cov0" title="0">{
                handler.ServeHTTP(w, r)
        }</span>
}

// PanicHandler is a handler for panics that also takes an error.
type PanicHandler func(http.ResponseWriter, *http.Request, interface{})

// Route is an entry in the route tree.
type Route struct {
        Handler
        Method string
        Path   string
        Params []string
}

// String returns a string representation of the route.
// Namely: Method_Path
func (r Route) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s_%s", r.Method, r.Path)
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package web

// RouteParameters are parameters sourced from parsing the request path (route).
type RouteParameters map[string]string

// Get gets a value for a key.
func (rp RouteParameters) Get(key string) string <span class="cov8" title="1">{
        return rp[key]
}</span>

// Has returns if the collection has a key or not.
func (rp RouteParameters) Has(key string) bool <span class="cov0" title="0">{
        _, ok := rp[key]
        return ok
}</span>

// Set stores a value for a key.
func (rp RouteParameters) Set(key, value string) <span class="cov0" title="0">{
        rp[key] = value
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package web

import (
        "sync"
        "time"
)

// NewSession returns a new session object.
func NewSession(userID string, sessionID string) *Session <span class="cov8" title="1">{
        return &amp;Session{
                UserID:     userID,
                SessionID:  sessionID,
                CreatedUTC: time.Now().UTC(),
                State:      map[string]interface{}{},
                Mutex:      &amp;sync.RWMutex{},
        }
}</span>

// Session is an active session
type Session struct {
        UserID     string                 `json:"userID" yaml:"userID"`
        SessionID  string                 `json:"sessionID" yaml:"sessionID"`
        CreatedUTC time.Time              `json:"createdUTC" yaml:"createdUTC"`
        ExpiresUTC *time.Time             `json:"expiresUTC" yaml:"expiresUTC"`
        State      map[string]interface{} `json:"state,omitempty" yaml:"state,omitempty"`
        Mutex      *sync.RWMutex          `json:"-" yaml:"-"`
}

// IsExpired returns if the session is expired.
func (s *Session) IsExpired() bool <span class="cov8" title="1">{
        if s == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if s.ExpiresUTC == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return s.ExpiresUTC.Before(time.Now().UTC())</span>
}

func (s *Session) ensureMutex() <span class="cov8" title="1">{
        if s.Mutex == nil </span><span class="cov8" title="1">{
                s.Mutex = &amp;sync.RWMutex{}
        }</span>
}

// IsZero returns if the object is set or not.
// It will return true if either the userID or the sessionID are unset.
func (s *Session) IsZero() bool <span class="cov8" title="1">{
        if s == nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">return len(s.UserID) == 0 || len(s.SessionID) == 0</span>
}

// Lock locks the session.
func (s *Session) Lock() <span class="cov0" title="0">{
        s.ensureMutex()
        s.Mutex.Lock()
}</span>

// Unlock unlocks the session.
func (s *Session) Unlock() <span class="cov0" title="0">{
        s.ensureMutex()
        s.Mutex.Unlock()
}</span>

// RLock read locks the session.
func (s *Session) RLock() <span class="cov8" title="1">{
        s.ensureMutex()
        s.Mutex.RLock()
}</span>

// RUnlock read unlocks the session.
func (s *Session) RUnlock() <span class="cov8" title="1">{
        s.ensureMutex()
        s.Mutex.RUnlock()
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package web

import (
        "sync"
)

// NewSessionCache returns a new session cache.
func NewSessionCache() *SessionCache <span class="cov8" title="1">{
        return &amp;SessionCache{
                SessionLock: &amp;sync.Mutex{},
                Sessions:    map[string]*Session{},
        }
}</span>

// SessionCache is a memory ledger of active sessions.
type SessionCache struct {
        SessionLock *sync.Mutex
        Sessions    map[string]*Session
}

// Upsert adds or updates a session to the cache.
func (sc *SessionCache) Upsert(session *Session) <span class="cov8" title="1">{
        sc.SessionLock.Lock()
        defer sc.SessionLock.Unlock()
        sc.Sessions[session.SessionID] = session
}</span>

// Remove removes a session from the cache.
func (sc *SessionCache) Remove(sessionID string) <span class="cov8" title="1">{
        sc.SessionLock.Lock()
        defer sc.SessionLock.Unlock()
        delete(sc.Sessions, sessionID)
}</span>

// Get gets a session.
func (sc *SessionCache) Get(sessionID string) *Session <span class="cov8" title="1">{
        sc.SessionLock.Lock()
        defer sc.SessionLock.Unlock()

        if session, hasSession := sc.Sessions[sessionID]; hasSession </span><span class="cov8" title="1">{
                return session
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// IsActive returns if a sessionID is active.
func (sc *SessionCache) IsActive(sessionID string) bool <span class="cov8" title="1">{
        sc.SessionLock.Lock()
        defer sc.SessionLock.Unlock()

        session, hasSession := sc.Sessions[sessionID]
        if hasSession </span><span class="cov8" title="1">{
                return !session.IsExpired()
        }</span>
        <span class="cov8" title="1">return hasSession</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package web

// SessionAware is an action that injects the session into the context, it acquires a read lock on session.
func SessionAware(action Action) Action <span class="cov8" title="1">{
        return sessionMiddleware(action, nil, SessionReadLock)
}</span>

// SessionAwareMutating is an action that injects the session into the context and requires a write lock.
func SessionAwareMutating(action Action) Action <span class="cov0" title="0">{
        return sessionMiddleware(action, nil, SessionReadWriteLock)
}</span>

// SessionAwareUnsafe is an action that injects the session into the context without acquiring any (read or write) locks.
func SessionAwareUnsafe(action Action) Action <span class="cov0" title="0">{
        return sessionMiddleware(action, nil, SessionUnsafe)
}</span>

// SessionRequired is an action that requires a session to be present
// or identified in some form on the request, and acquires a read lock on session.
func SessionRequired(action Action) Action <span class="cov8" title="1">{
        return sessionMiddleware(action, AuthManagerRedirect, SessionReadLock)
}</span>

// SessionRequiredMutating is an action that requires the session to present and also requires a write lock.
func SessionRequiredMutating(action Action) Action <span class="cov0" title="0">{
        return sessionMiddleware(action, AuthManagerRedirect, SessionReadWriteLock)
}</span>

// SessionRequiredUnsafe is an action that requires the session to present and does not acquire any (read or write) locks.
func SessionRequiredUnsafe(action Action) Action <span class="cov0" title="0">{
        return sessionMiddleware(action, AuthManagerRedirect, SessionUnsafe)
}</span>

// AuthManagerRedirect is a redirect.
func AuthManagerRedirect(ctx *Ctx) Result <span class="cov8" title="1">{
        return ctx.Auth().Redirect(ctx)
}</span>

// SessionMiddleware creates a custom session middleware.
func SessionMiddleware(notAuthorized Action, lockPolicy SessionLockPolicy) Middleware <span class="cov0" title="0">{
        return func(action Action) Action </span><span class="cov0" title="0">{
                return sessionMiddleware(action, notAuthorized, lockPolicy)
        }</span>
}

// SessionMiddleware returns a session middleware.
func sessionMiddleware(action, notAuthorized Action, lockPolicy SessionLockPolicy) Action <span class="cov8" title="1">{
        return func(ctx *Ctx) Result </span><span class="cov8" title="1">{
                session, err := ctx.Auth().VerifySession(ctx)
                if err != nil &amp;&amp; !IsErrSessionInvalid(err) </span><span class="cov0" title="0">{
                        return ctx.DefaultResultProvider().InternalError(err)
                }</span>

                <span class="cov8" title="1">if session == nil </span><span class="cov8" title="1">{
                        if notAuthorized != nil </span><span class="cov8" title="1">{
                                return notAuthorized(ctx)
                        }</span>
                        <span class="cov8" title="1">return action(ctx)</span>
                }

                <span class="cov8" title="1">switch lockPolicy </span>{
                case SessionReadLock:<span class="cov8" title="1">
                        </span><span class="cov8" title="1">{
                                session.RLock()
                                defer session.RUnlock()
                                break</span>
                        }
                case SessionReadWriteLock:<span class="cov0" title="0">
                        </span><span class="cov0" title="0">{
                                session.Lock()
                                defer session.Unlock()
                                break</span>
                        }
                }

                <span class="cov8" title="1">ctx.WithSession(session)
                return action(ctx)</span>
        }
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package web

import "database/sql"

const (
        // StateKeyTx is the app state key for a transaction.
        StateKeyTx = "tx"
)

// State is the collection of state objects on a context.
type State map[string]interface{}

// StateProvider provide states, an example is Ctx
type StateProvider interface {
        State() State
}

// StateValueProvider is a type that provides a state value.
type StateValueProvider interface {
        StateValue(key string) interface{}
}

// Tx returns the transaction for the request.
// keys is an optional parameter used for additional arbitrary transactions
func Tx(sp StateProvider, optionalKey ...string) *sql.Tx <span class="cov8" title="1">{
        if sp == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return TxFromState(sp.State(), optionalKey...)</span>
}

// TxFromState returns a tx from a state bag.
func TxFromState(state State, keys ...string) *sql.Tx <span class="cov8" title="1">{
        if state == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">key := StateKeyTx
        if len(keys) &gt; 0 </span><span class="cov8" title="1">{
                key = keys[0]
        }</span>
        <span class="cov8" title="1">if typed, isTyped := state[key].(*sql.Tx); isTyped </span><span class="cov8" title="1">{
                return typed
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// WithTx sets a transaction on the state provider.
func WithTx(sp StateProvider, tx *sql.Tx, keys ...string) StateProvider <span class="cov8" title="1">{
        if sp == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">state := sp.State()
        if state == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">WithTxForState(state, tx, keys...)
        return sp</span>
}

// WithTxForState injects a tx into a statebag.
func WithTxForState(state State, tx *sql.Tx, keys ...string) <span class="cov8" title="1">{
        key := StateKeyTx
        if len(keys) &gt; 0 </span><span class="cov8" title="1">{
                key = keys[0]
        }</span>
        <span class="cov8" title="1">state[key] = tx</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package web

import (
        "net/http"
        "os"
        "regexp"

        "github.com/blend/go-sdk/logger"
)

// NewStaticFileServer returns a new static file cache.
func NewStaticFileServer(fs http.FileSystem) *StaticFileServer <span class="cov8" title="1">{
        return &amp;StaticFileServer{
                fileSystem: fs,
        }
}</span>

// StaticFileServer is a cache of static files.
type StaticFileServer struct {
        log          *logger.Logger
        fileSystem   http.FileSystem
        rewriteRules []RewriteRule
        middleware   Action
        headers      http.Header
}

// Log returns a logger reference.
func (sc *StaticFileServer) Log() *logger.Logger <span class="cov0" title="0">{
        return sc.log
}</span>

// WithLogger sets the logger reference for the static file cache.
func (sc *StaticFileServer) WithLogger(log *logger.Logger) *StaticFileServer <span class="cov0" title="0">{
        sc.log = log
        return sc
}</span>

// AddHeader adds a header to the static cache results.
func (sc *StaticFileServer) AddHeader(key, value string) <span class="cov8" title="1">{
        if sc.headers == nil </span><span class="cov8" title="1">{
                sc.headers = http.Header{}
        }</span>
        <span class="cov8" title="1">sc.headers[key] = append(sc.headers[key], value)</span>
}

// Headers returns the headers for the static server.
func (sc *StaticFileServer) Headers() http.Header <span class="cov8" title="1">{
        return sc.headers
}</span>

// AddRewriteRule adds a static re-write rule.
func (sc *StaticFileServer) AddRewriteRule(match string, action RewriteAction) error <span class="cov8" title="1">{
        expr, err := regexp.Compile(match)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">sc.rewriteRules = append(sc.rewriteRules, RewriteRule{
                MatchExpression: match,
                expr:            expr,
                Action:          action,
        })
        return nil</span>
}

// SetMiddleware sets the middlewares.
func (sc *StaticFileServer) SetMiddleware(middlewares ...Middleware) <span class="cov8" title="1">{
        sc.middleware = NestMiddleware(sc.ServeFile, middlewares...)
}</span>

// RewriteRules returns the rewrite rules
func (sc *StaticFileServer) RewriteRules() []RewriteRule <span class="cov8" title="1">{
        return sc.rewriteRules
}</span>

// Action is the entrypoint for the static server.
// It will run middleware if specified before serving the file.
func (sc *StaticFileServer) Action(r *Ctx) Result <span class="cov8" title="1">{
        if sc.middleware != nil </span><span class="cov8" title="1">{
                return sc.middleware(r)
        }</span>
        <span class="cov8" title="1">return sc.ServeFile(r)</span>
}

// ServeFile writes the file to the response without running middleware.
func (sc *StaticFileServer) ServeFile(r *Ctx) Result <span class="cov8" title="1">{
        for key, values := range sc.headers </span><span class="cov8" title="1">{
                for _, value := range values </span><span class="cov8" title="1">{
                        r.Response().Header().Set(key, value)
                }</span>
        }

        <span class="cov8" title="1">filePath, err := r.RouteParam("filepath")
        if err != nil </span><span class="cov0" title="0">{
                return r.DefaultResultProvider().InternalError(err)
        }</span>

        <span class="cov8" title="1">for _, rule := range sc.rewriteRules </span><span class="cov8" title="1">{
                if matched, newFilePath := rule.Apply(filePath); matched </span><span class="cov8" title="1">{
                        filePath = newFilePath
                }</span>
        }

        <span class="cov8" title="1">f, err := sc.fileSystem.Open(filePath)
        if f == nil || os.IsNotExist(err) </span><span class="cov0" title="0">{
                return r.DefaultResultProvider().NotFound()
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return r.DefaultResultProvider().InternalError(err)
        }</span>
        <span class="cov8" title="1">defer f.Close()

        d, err := f.Stat()
        if err != nil </span><span class="cov0" title="0">{
                return r.DefaultResultProvider().InternalError(err)
        }</span>

        <span class="cov8" title="1">http.ServeContent(r.Response(), r.Request(), filePath, d.ModTime(), f)
        return nil</span>

}
</pre>
		
		<pre class="file" id="file32" style="display: none">package web

import (
        "net/http"
        "path"
)

// NewStaticResultForFile returns a static result for an individual file.
func NewStaticResultForFile(filePath string) *StaticResult <span class="cov8" title="1">{
        file := path.Base(filePath)
        root := path.Dir(filePath)
        return &amp;StaticResult{
                FilePath:   file,
                FileSystem: http.Dir(root),
        }
}</span>

// StaticResult represents a static output.
type StaticResult struct {
        FilePath     string
        FileSystem   http.FileSystem
        RewriteRules []RewriteRule
        Headers      http.Header
}

// Render renders a static result.
func (sr StaticResult) Render(ctx *Ctx) error <span class="cov8" title="1">{
        filePath := sr.FilePath
        for _, rule := range sr.RewriteRules </span><span class="cov0" title="0">{
                if matched, newFilePath := rule.Apply(filePath); matched </span><span class="cov0" title="0">{
                        filePath = newFilePath
                }</span>
        }

        <span class="cov8" title="1">for key, values := range sr.Headers </span><span class="cov0" title="0">{
                for _, value := range values </span><span class="cov0" title="0">{
                        ctx.Response().Header().Add(key, value)
                }</span>
        }

        <span class="cov8" title="1">f, err := sr.FileSystem.Open(sr.FilePath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer f.Close()

        d, err := f.Stat()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">http.ServeContent(ctx.Response(), ctx.Request(), filePath, d.ModTime(), f)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package web

import (
        "net"
        "time"
)

const (
        // DefaultTCPKeepAliveListenerPeriod is the default keep alive period for the tcp listener.
        DefaultTCPKeepAliveListenerPeriod = 3 * time.Minute
)

// TCPKeepAliveListener sets TCP keep-alive timeouts on accepted
// connections. It's used by ListenAndServe and ListenAndServeTLS so
// dead TCP connections (e.g. closing laptop mid-download) eventually
// go away.
type TCPKeepAliveListener struct {
        *net.TCPListener
}

// Accept accepts the connection.
func (ln TCPKeepAliveListener) Accept() (net.Conn, error) <span class="cov8" title="1">{
        tc, err := ln.AcceptTCP()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">tc.SetKeepAlive(true)
        tc.SetKeepAlivePeriod(DefaultTCPKeepAliveListenerPeriod)
        return tc, nil</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package web

import (
        "fmt"
        "net/http"

        "github.com/blend/go-sdk/logger"
)

// NewTextResultProvider returns a new text result provider.
func NewTextResultProvider(log *logger.Logger) *TextResultProvider <span class="cov0" title="0">{
        return &amp;TextResultProvider{log: log}
}</span>

// TextResultProvider is the default response provider if none is specified.
type TextResultProvider struct {
        log *logger.Logger
}

// NotFound returns a text response.
func (trp *TextResultProvider) NotFound() Result <span class="cov0" title="0">{
        return &amp;RawResult{
                StatusCode:  http.StatusNotFound,
                ContentType: ContentTypeText,
                Body:        []byte("Not Found"),
        }
}</span>

// NotAuthorized returns a text response.
func (trp *TextResultProvider) NotAuthorized() Result <span class="cov8" title="1">{
        return &amp;RawResult{
                StatusCode:  http.StatusForbidden,
                ContentType: ContentTypeText,
                Body:        []byte("Not Authorized"),
        }
}</span>

// InternalError returns a text response.
func (trp *TextResultProvider) InternalError(err error) Result <span class="cov8" title="1">{
        if trp.log != nil </span><span class="cov0" title="0">{
                trp.log.Fatal(err)
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return &amp;RawResult{
                        StatusCode:  http.StatusInternalServerError,
                        ContentType: ContentTypeText,
                        Body:        []byte(err.Error()),
                }
        }</span>

        <span class="cov0" title="0">return &amp;RawResult{
                StatusCode:  http.StatusInternalServerError,
                ContentType: ContentTypeText,
                Body:        []byte("An internal server error occurred."),
        }</span>
}

// BadRequest returns a text response.
func (trp *TextResultProvider) BadRequest(err error) Result <span class="cov0" title="0">{
        if err != nil </span><span class="cov0" title="0">{
                return &amp;RawResult{
                        StatusCode:  http.StatusBadRequest,
                        ContentType: ContentTypeText,
                        Body:        []byte(fmt.Sprintf("Bad Request: %v", err)),
                }
        }</span>
        <span class="cov0" title="0">return &amp;RawResult{
                StatusCode:  http.StatusBadRequest,
                ContentType: ContentTypeText,
                Body:        []byte("Bad Request"),
        }</span>
}

// Result returns a plaintext result.
func (trp *TextResultProvider) Result(response interface{}) Result <span class="cov8" title="1">{
        return &amp;RawResult{
                StatusCode:  http.StatusOK,
                ContentType: ContentTypeText,
                Body:        []byte(fmt.Sprintf("%s", response)),
        }
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">package web

import (
        "crypto/tls"
        "crypto/x509"
        "io/ioutil"

        "github.com/blend/go-sdk/exception"
        "github.com/blend/go-sdk/util"
)

// TLSConfig is a config for app tls settings.
type TLSConfig struct {
        Cert     []byte `json:"cert" yaml:"cert" env:"TLS_CERT"`
        CertPath string `json:"certPath" yaml:"certPath" env:"TLS_CERT_PATH"`
        Key      []byte `json:"key" yaml:"key" env:"TLS_KEY"`
        KeyPath  string `json:"keyPath" yaml:"keyPath" env:"TLS_KEY_PATH"`

        CAPaths []string `json:"caPaths" yaml:"caPaths" env:"TLS_CA_PATHS,csv"`
}

// GetCert returns a tls cert.
func (tc TLSConfig) GetCert(defaults ...[]byte) []byte <span class="cov8" title="1">{
        return util.Coalesce.Bytes(tc.Cert, nil, defaults...)
}</span>

// GetCertPath returns a tls cert path.
func (tc TLSConfig) GetCertPath(defaults ...string) string <span class="cov8" title="1">{
        return util.Coalesce.String(tc.CertPath, "", defaults...)
}</span>

// GetKey returns a tls key.
func (tc TLSConfig) GetKey(defaults ...[]byte) []byte <span class="cov0" title="0">{
        return util.Coalesce.Bytes(tc.Key, nil, defaults...)
}</span>

// GetKeyPath returns a tls key path.
func (tc TLSConfig) GetKeyPath(defaults ...string) string <span class="cov8" title="1">{
        return util.Coalesce.String(tc.KeyPath, "", defaults...)
}</span>

// GetCAPaths returns a list of ca paths to add.
func (tc TLSConfig) GetCAPaths(defaults ...[]string) []string <span class="cov8" title="1">{
        return util.Coalesce.Strings(tc.CAPaths, nil, defaults...)
}</span>

// GetConfig returns a stdlib tls config for the config.
func (tc TLSConfig) GetConfig() (*tls.Config, error) <span class="cov8" title="1">{
        if !tc.HasKeyPair() </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">var cert tls.Certificate
        var err error

        if len(tc.GetCertPath()) &gt; 0 </span><span class="cov8" title="1">{
                cert, err = tls.LoadX509KeyPair(
                        tc.GetCertPath(),
                        tc.GetKeyPath(),
                )
        }</span> else<span class="cov0" title="0"> {
                cert, err = tls.X509KeyPair(tc.GetCert(), tc.GetKey())
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, exception.Wrap(err)
        }</span>

        <span class="cov8" title="1">if len(tc.GetCAPaths()) == 0 </span><span class="cov8" title="1">{
                return &amp;tls.Config{
                        Certificates: []tls.Certificate{cert},
                }, nil
        }</span>

        <span class="cov0" title="0">certPool, err := x509.SystemCertPool()
        if err != nil </span><span class="cov0" title="0">{
                return nil, exception.Wrap(err)
        }</span>
        <span class="cov0" title="0">for _, caPath := range tc.GetCAPaths() </span><span class="cov0" title="0">{
                caCert, err := ioutil.ReadFile(caPath)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, exception.Wrap(err)
                }</span>
                <span class="cov0" title="0">certPool.AppendCertsFromPEM(caCert)</span>
        }

        <span class="cov0" title="0">return &amp;tls.Config{
                Certificates: []tls.Certificate{cert},
                RootCAs:      certPool,
        }, nil</span>
}

// HasKeyPair returns if the config names a keypair.
func (tc TLSConfig) HasKeyPair() bool <span class="cov8" title="1">{
        if len(tc.GetCert()) &gt; 0 &amp;&amp; len(tc.GetKey()) &gt; 0 </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="1">if len(tc.GetCertPath()) &gt; 0 &amp;&amp; len(tc.GetKeyPath()) &gt; 0 </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">// Copyright 2013 Julien Schmidt. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be found
// in the LICENSE file.

package web

import (
        "strings"
        "unicode"
        "unicode/utf8"
)

type nodeType uint8

const (
        static nodeType = iota // default
        root
        param
        catchAll
)

type node struct {
        nodeType
        path       string
        isWildcard bool
        maxParams  uint8
        indices    string
        children   []*node
        route      *Route
        priority   uint32
}

// incrementChildPriority increments priority of the given child and reorders if necessary
func (n *node) incrementChildPriority(index int) int <span class="cov8" title="1">{
        n.children[index].priority++
        priority := n.children[index].priority

        // adjust position (move to front)
        newIndex := index
        for newIndex &gt; 0 &amp;&amp; n.children[newIndex-1].priority &lt; priority </span><span class="cov8" title="1">{
                // swap node positions
                temp := n.children[newIndex-1]
                n.children[newIndex-1] = n.children[newIndex]
                n.children[newIndex] = temp
                newIndex--
        }</span>

        // build new index char string
        <span class="cov8" title="1">if newIndex != index </span><span class="cov8" title="1">{
                n.indices = n.indices[:newIndex] + // unchanged prefix, might be empty
                        n.indices[index:index+1] + // the index char we move
                        n.indices[newIndex:index] + n.indices[index+1:] // rest without char at 'pos'
        }</span>

        <span class="cov8" title="1">return newIndex</span>
}

// addRoute adds a node with the given handle to the path.
// Not concurrency-safe!
func (n *node) addRoute(method, path string, handler Handler) <span class="cov8" title="1">{
        fullPath := path
        n.priority++
        numParams := countParams(path)

        // non-empty tree
        if len(n.path) &gt; 0 || len(n.children) &gt; 0 </span><span class="cov8" title="1">{
        walk:
                for </span><span class="cov8" title="1">{
                        // Update maxParams of the current node
                        if numParams &gt; n.maxParams </span><span class="cov8" title="1">{
                                n.maxParams = numParams
                        }</span>

                        // Find the longest common prefix.
                        // This also implies that the common prefix contains no ':' or '*'
                        // since the existing key can't contain those chars.
                        <span class="cov8" title="1">i := 0
                        max := min(len(path), len(n.path))
                        for i &lt; max &amp;&amp; path[i] == n.path[i] </span><span class="cov8" title="1">{
                                i++
                        }</span>

                        // Split edge
                        <span class="cov8" title="1">if i &lt; len(n.path) </span><span class="cov8" title="1">{
                                child := node{
                                        path:       n.path[i:],
                                        isWildcard: n.isWildcard,
                                        nodeType:   static,
                                        indices:    n.indices,
                                        children:   n.children,
                                        route:      n.route,
                                        priority:   n.priority - 1,
                                }

                                // Update maxParams (max of all children)
                                for i := range child.children </span><span class="cov8" title="1">{
                                        if child.children[i].maxParams &gt; child.maxParams </span><span class="cov8" title="1">{
                                                child.maxParams = child.children[i].maxParams
                                        }</span>
                                }

                                <span class="cov8" title="1">n.children = []*node{&amp;child}
                                // []byte for proper unicode char conversion, see #65
                                n.indices = string([]byte{n.path[i]})
                                n.path = path[:i]
                                n.route = nil
                                n.isWildcard = false</span>
                        }

                        // Make new node a child of this node
                        <span class="cov8" title="1">if i &lt; len(path) </span><span class="cov8" title="1">{
                                path = path[i:]

                                if n.isWildcard </span><span class="cov8" title="1">{
                                        n = n.children[0]
                                        n.priority++

                                        // Update maxParams of the child node
                                        if numParams &gt; n.maxParams </span><span class="cov8" title="1">{
                                                n.maxParams = numParams
                                        }</span>
                                        <span class="cov8" title="1">numParams--

                                        // Check if the wildcard matches
                                        if len(path) &gt;= len(n.path) &amp;&amp; n.path == path[:len(n.path)] </span><span class="cov8" title="1">{
                                                // check for longer wildcard, e.g. :name and :names
                                                if len(n.path) &gt;= len(path) || path[len(n.path)] == '/' </span><span class="cov8" title="1">{
                                                        continue walk</span>
                                                }
                                        }

                                        <span class="cov8" title="1">panic("path segment '" + path +
                                                "' conflicts with existing wildcard '" + n.path +
                                                "' in path '" + fullPath + "'")</span>
                                }

                                <span class="cov8" title="1">c := path[0]

                                // slash after param
                                if n.nodeType == param &amp;&amp; c == '/' &amp;&amp; len(n.children) == 1 </span><span class="cov8" title="1">{
                                        n = n.children[0]
                                        n.priority++
                                        continue walk</span>
                                }

                                // Check if a child with the next path byte exists
                                <span class="cov8" title="1">for i := 0; i &lt; len(n.indices); i++ </span><span class="cov8" title="1">{
                                        if c == n.indices[i] </span><span class="cov8" title="1">{
                                                i = n.incrementChildPriority(i)
                                                n = n.children[i]
                                                continue walk</span>
                                        }
                                }

                                // Otherwise insert it
                                <span class="cov8" title="1">if c != ':' &amp;&amp; c != '*' </span><span class="cov8" title="1">{
                                        // []byte for proper unicode char conversion, see #65
                                        n.indices += string([]byte{c})
                                        child := &amp;node{
                                                maxParams: numParams,
                                        }
                                        n.children = append(n.children, child)
                                        n.incrementChildPriority(len(n.indices) - 1)
                                        n = child
                                }</span>
                                <span class="cov8" title="1">n.insertChild(numParams, method, path, fullPath, handler)
                                return</span>

                        } else<span class="cov8" title="1"> if i == len(path) </span><span class="cov8" title="1">{ // Make node a (in-path) leaf
                                if n.route != nil </span><span class="cov8" title="1">{
                                        panic("a handle is already registered for path '" + fullPath + "'")</span>
                                }
                                <span class="cov8" title="1">n.route = &amp;Route{
                                        Handler: handler,
                                        Path:    fullPath,
                                        Method:  method,
                                }</span>
                        }
                        <span class="cov8" title="1">return</span>
                }
        } else<span class="cov8" title="1"> { // Empty tree
                n.insertChild(numParams, method, path, fullPath, handler)
                n.nodeType = root
        }</span>
}

func (n *node) insertChild(numParams uint8, method, path, fullPath string, handler Handler) <span class="cov8" title="1">{
        var offset int // already handled bytes of the path

        // find prefix until first wildcard (beginning with ':'' or '*'')
        for i, max := 0, len(path); numParams &gt; 0; i++ </span><span class="cov8" title="1">{
                c := path[i]
                if c != ':' &amp;&amp; c != '*' </span><span class="cov8" title="1">{
                        continue</span>
                }

                // find wildcard end (either '/' or path end)
                <span class="cov8" title="1">end := i + 1
                for end &lt; max &amp;&amp; path[end] != '/' </span><span class="cov8" title="1">{
                        switch path[end] </span>{
                        // the wildcard name must not contain ':' and '*'
                        case ':', '*':<span class="cov8" title="1">
                                panic("only one wildcard per path segment is allowed, has: '" +
                                        path[i:] + "' in path '" + fullPath + "'")</span>
                        default:<span class="cov8" title="1">
                                end++</span>
                        }
                }

                // check if this Node existing children which would be
                // unreachable if we insert the wildcard here
                <span class="cov8" title="1">if len(n.children) &gt; 0 </span><span class="cov8" title="1">{
                        panic("wildcard route '" + path[i:end] +
                                "' conflicts with existing children in path '" + fullPath + "'")</span>
                }

                // check if the wildcard has a name
                <span class="cov8" title="1">if end-i &lt; 2 </span><span class="cov8" title="1">{
                        panic("wildcards must be named with a non-empty name in path '" + fullPath + "'")</span>
                }

                <span class="cov8" title="1">if c == ':' </span><span class="cov8" title="1">{ // param
                        // split path at the beginning of the wildcard
                        if i &gt; 0 </span><span class="cov8" title="1">{
                                n.path = path[offset:i]
                                offset = i
                        }</span>

                        <span class="cov8" title="1">child := &amp;node{
                                nodeType:  param,
                                maxParams: numParams,
                        }
                        n.children = []*node{child}
                        n.isWildcard = true
                        n = child
                        n.priority++
                        numParams--

                        // if the path doesn't end with the wildcard, then there
                        // will be another non-wildcard subpath starting with '/'
                        if end &lt; max </span><span class="cov8" title="1">{
                                n.path = path[offset:end]
                                offset = end

                                child := &amp;node{
                                        maxParams: numParams,
                                        priority:  1,
                                }
                                n.children = []*node{child}
                                n = child
                        }</span>

                } else<span class="cov8" title="1"> { // catchAll
                        if end != max || numParams &gt; 1 </span><span class="cov8" title="1">{
                                panic("catch-all routes are only allowed at the end of the path in path '" + fullPath + "'")</span>
                        }

                        <span class="cov8" title="1">if len(n.path) &gt; 0 &amp;&amp; n.path[len(n.path)-1] == '/' </span><span class="cov8" title="1">{
                                panic("catch-all conflicts with existing handle for the path segment root in path '" + fullPath + "'")</span>
                        }

                        // currently fixed width 1 for '/'
                        <span class="cov8" title="1">i--
                        if path[i] != '/' </span><span class="cov8" title="1">{
                                panic("no / before catch-all in path '" + fullPath + "'")</span>
                        }

                        <span class="cov8" title="1">n.path = path[offset:i]

                        // first node: catchAll node with empty path
                        child := &amp;node{
                                isWildcard: true,
                                nodeType:   catchAll,
                                maxParams:  1,
                        }
                        n.children = []*node{child}
                        n.indices = string(path[i])
                        n = child
                        n.priority++

                        // second node: node holding the variable
                        child = &amp;node{
                                path:      path[i:],
                                nodeType:  catchAll,
                                maxParams: 1,
                                route: &amp;Route{
                                        Handler: handler,
                                        Path:    fullPath,
                                        Method:  method,
                                },
                                priority: 1,
                        }
                        n.children = []*node{child}

                        return</span>
                }
        }

        // insert remaining path part and handle to the leaf
        <span class="cov8" title="1">n.path = path[offset:]
        n.route = &amp;Route{
                Handler: handler,
                Path:    fullPath,
                Method:  method,
        }</span>
}

// Returns the handle registered with the given path (key). The values of
// wildcards are saved to a map.
// If no handle can be found, a TSR (trailing slash redirect) recommendation is
// made if a handle exists with an extra (without the) trailing slash for the
// given path.
func (n *node) getValue(path string) (route *Route, p RouteParameters, tsr bool) <span class="cov8" title="1">{
walk: // outer loop for walking the tree
        for </span><span class="cov8" title="1">{
                if len(path) &gt; len(n.path) </span><span class="cov8" title="1">{
                        if path[:len(n.path)] == n.path </span><span class="cov8" title="1">{
                                path = path[len(n.path):]
                                // If this node does not have a wildcard (param or catchAll)
                                // child,  we can just look up the next child node and continue
                                // to walk down the tree
                                if !n.isWildcard </span><span class="cov8" title="1">{
                                        c := path[0]
                                        for i := 0; i &lt; len(n.indices); i++ </span><span class="cov8" title="1">{
                                                if c == n.indices[i] </span><span class="cov8" title="1">{
                                                        n = n.children[i]
                                                        continue walk</span>
                                                }
                                        }

                                        // Nothing found.
                                        // We can recommend to redirect to the same URL without a
                                        // trailing slash if a leaf exists for that path.
                                        <span class="cov8" title="1">tsr = (path == "/" &amp;&amp; n.route != nil)
                                        return</span>
                                }

                                // handle wildcard child
                                <span class="cov8" title="1">n = n.children[0]
                                switch n.nodeType </span>{
                                case param:<span class="cov8" title="1">
                                        // find param end (either '/' or path end)
                                        end := 0
                                        for end &lt; len(path) &amp;&amp; path[end] != '/' </span><span class="cov8" title="1">{
                                                end++
                                        }</span>

                                        // save param value
                                        <span class="cov8" title="1">if p == nil </span><span class="cov8" title="1">{
                                                // lazy allocation
                                                p = make(RouteParameters)
                                        }</span>
                                        <span class="cov8" title="1">p[n.path[1:]] = path[:end]

                                        // we need to go deeper!
                                        if end &lt; len(path) </span><span class="cov8" title="1">{
                                                if len(n.children) &gt; 0 </span><span class="cov8" title="1">{
                                                        path = path[end:]
                                                        n = n.children[0]
                                                        continue walk</span>
                                                }

                                                // ... but we can't
                                                <span class="cov8" title="1">tsr = (len(path) == end+1)
                                                return</span>
                                        }

                                        <span class="cov8" title="1">if route = n.route; route != nil </span><span class="cov8" title="1">{
                                                return
                                        }</span> else<span class="cov8" title="1"> if len(n.children) == 1 </span><span class="cov8" title="1">{
                                                // No handle found. Check if a handle for this path + a
                                                // trailing slash exists for TSR recommendation
                                                n = n.children[0]
                                                tsr = (n.path == "/" &amp;&amp; n.route != nil)
                                        }</span>

                                        <span class="cov8" title="1">return</span>

                                case catchAll:<span class="cov8" title="1">
                                        // save param value
                                        if p == nil </span><span class="cov8" title="1">{
                                                // lazy allocation
                                                p = make(RouteParameters)
                                        }</span>

                                        <span class="cov8" title="1">p[n.path[2:]] = path[:]

                                        route = n.route
                                        return</span>

                                default:<span class="cov8" title="1">
                                        panic("invalid node type")</span>
                                }
                        }
                } else<span class="cov8" title="1"> if path == n.path </span><span class="cov8" title="1">{
                        // We should have reached the node containing the handle.
                        // Check if this node has a handle registered.
                        if route = n.route; route != nil </span><span class="cov8" title="1">{
                                return
                        }</span>

                        <span class="cov8" title="1">if path == "/" &amp;&amp; n.isWildcard &amp;&amp; n.nodeType != root </span><span class="cov8" title="1">{
                                tsr = true
                                return
                        }</span>

                        // No handle found. Check if a handle for this path + a
                        // trailing slash exists for trailing slash recommendation
                        <span class="cov8" title="1">for i := 0; i &lt; len(n.indices); i++ </span><span class="cov8" title="1">{
                                if n.indices[i] == '/' </span><span class="cov8" title="1">{
                                        n = n.children[i]
                                        tsr = (len(n.path) == 1 &amp;&amp; n.route != nil) ||
                                                (n.nodeType == catchAll &amp;&amp; n.children[0].route != nil)
                                        return
                                }</span>
                        }

                        <span class="cov8" title="1">return</span>
                }

                // Nothing found. We can recommend to redirect to the same URL with an
                // extra trailing slash if a leaf exists for that path
                <span class="cov8" title="1">tsr = (path == "/") ||
                        (len(n.path) == len(path)+1 &amp;&amp; n.path[len(path)] == '/' &amp;&amp;
                                path == n.path[:len(n.path)-1] &amp;&amp; n.route != nil)
                return</span>
        }
}

// Makes a case-insensitive lookup of the given path and tries to find a handler.
// It can optionally also fix trailing slashes.
// It returns the case-corrected path and a bool indicating whether the lookup
// was successful.
func (n *node) findCaseInsensitivePath(path string, fixTrailingSlash bool) (ciPath []byte, found bool) <span class="cov8" title="1">{
        return n.findCaseInsensitivePathRec(
                path,
                strings.ToLower(path),
                make([]byte, 0, len(path)+1), // preallocate enough memory for new path
                [4]byte{},                    // empty rune buffer
                fixTrailingSlash,
        )
}</span>

// shift bytes in array by n bytes left
func shiftNRuneBytes(rb [4]byte, n int) [4]byte <span class="cov8" title="1">{
        switch n </span>{
        case 0:<span class="cov8" title="1">
                return rb</span>
        case 1:<span class="cov8" title="1">
                return [4]byte{rb[1], rb[2], rb[3], 0}</span>
        case 2:<span class="cov8" title="1">
                return [4]byte{rb[2], rb[3]}</span>
        case 3:<span class="cov8" title="1">
                return [4]byte{rb[3]}</span>
        default:<span class="cov8" title="1">
                return [4]byte{}</span>
        }
}

// recursive case-insensitive lookup function used by n.findCaseInsensitivePath
func (n *node) findCaseInsensitivePathRec(path, loPath string, ciPath []byte, rb [4]byte, fixTrailingSlash bool) ([]byte, bool) <span class="cov8" title="1">{
        loNPath := strings.ToLower(n.path)

walk: // outer loop for walking the tree
        for len(loPath) &gt;= len(loNPath) &amp;&amp; (len(loNPath) == 0 || loPath[1:len(loNPath)] == loNPath[1:]) </span><span class="cov8" title="1">{
                // add common path to result
                ciPath = append(ciPath, n.path...)

                if path = path[len(n.path):]; len(path) &gt; 0 </span><span class="cov8" title="1">{
                        loOld := loPath
                        loPath = loPath[len(loNPath):]

                        // If this node does not have a wildcard (param or catchAll) child,
                        // we can just look up the next child node and continue to walk down
                        // the tree
                        if !n.isWildcard </span><span class="cov8" title="1">{
                                // skip rune bytes already processed
                                rb = shiftNRuneBytes(rb, len(loNPath))

                                if rb[0] != 0 </span><span class="cov8" title="1">{
                                        // old rune not finished
                                        for i := 0; i &lt; len(n.indices); i++ </span><span class="cov8" title="1">{
                                                if n.indices[i] == rb[0] </span><span class="cov8" title="1">{
                                                        // continue with child node
                                                        n = n.children[i]
                                                        loNPath = strings.ToLower(n.path)
                                                        continue walk</span>
                                                }
                                        }
                                } else<span class="cov8" title="1"> {
                                        // process a new rune
                                        var rv rune

                                        // find rune start
                                        // runes are up to 4 byte long,
                                        // -4 would definitely be another rune
                                        var off int
                                        for max := min(len(loNPath), 3); off &lt; max; off++ </span><span class="cov8" title="1">{
                                                if i := len(loNPath) - off; utf8.RuneStart(loOld[i]) </span><span class="cov8" title="1">{
                                                        // read rune from cached lowercase path
                                                        rv, _ = utf8.DecodeRuneInString(loOld[i:])
                                                        break</span>
                                                }
                                        }

                                        // calculate lowercase bytes of current rune
                                        <span class="cov8" title="1">utf8.EncodeRune(rb[:], rv)
                                        // skipp already processed bytes
                                        rb = shiftNRuneBytes(rb, off)

                                        for i := 0; i &lt; len(n.indices); i++ </span><span class="cov8" title="1">{
                                                // lowercase matches
                                                if n.indices[i] == rb[0] </span><span class="cov8" title="1">{
                                                        // must use a recursive approach since both the
                                                        // uppercase byte and the lowercase byte might exist
                                                        // as an index
                                                        if out, found := n.children[i].findCaseInsensitivePathRec(
                                                                path, loPath, ciPath, rb, fixTrailingSlash,
                                                        ); found </span><span class="cov8" title="1">{
                                                                return out, true
                                                        }</span>
                                                        <span class="cov8" title="1">break</span>
                                                }
                                        }

                                        // same for uppercase rune, if it differs
                                        <span class="cov8" title="1">if up := unicode.ToUpper(rv); up != rv </span><span class="cov8" title="1">{
                                                utf8.EncodeRune(rb[:], up)
                                                rb = shiftNRuneBytes(rb, off)

                                                for i := 0; i &lt; len(n.indices); i++ </span><span class="cov8" title="1">{
                                                        // uppercase matches
                                                        if n.indices[i] == rb[0] </span><span class="cov8" title="1">{
                                                                // continue with child node
                                                                n = n.children[i]
                                                                loNPath = strings.ToLower(n.path)
                                                                continue walk</span>
                                                        }
                                                }
                                        }
                                }

                                // Nothing found. We can recommend to redirect to the same URL
                                // without a trailing slash if a leaf exists for that path
                                <span class="cov8" title="1">return ciPath, (fixTrailingSlash &amp;&amp; path == "/" &amp;&amp; n.route != nil)</span>
                        }

                        <span class="cov8" title="1">n = n.children[0]
                        switch n.nodeType </span>{
                        case param:<span class="cov8" title="1">
                                // find param end (either '/' or path end)
                                k := 0
                                for k &lt; len(path) &amp;&amp; path[k] != '/' </span><span class="cov8" title="1">{
                                        k++
                                }</span>

                                // add param value to case insensitive path
                                <span class="cov8" title="1">ciPath = append(ciPath, path[:k]...)

                                // we need to go deeper!
                                if k &lt; len(path) </span><span class="cov8" title="1">{
                                        if len(n.children) &gt; 0 </span><span class="cov8" title="1">{
                                                // continue with child node
                                                n = n.children[0]
                                                loNPath = strings.ToLower(n.path)
                                                loPath = loPath[k:]
                                                path = path[k:]
                                                continue</span>
                                        }

                                        // ... but we can't
                                        <span class="cov8" title="1">if fixTrailingSlash &amp;&amp; len(path) == k+1 </span><span class="cov8" title="1">{
                                                return ciPath, true
                                        }</span>
                                        <span class="cov8" title="1">return ciPath, false</span>
                                }

                                <span class="cov8" title="1">if n.route != nil </span><span class="cov8" title="1">{
                                        return ciPath, true
                                }</span> else<span class="cov8" title="1"> if fixTrailingSlash &amp;&amp; len(n.children) == 1 </span><span class="cov8" title="1">{
                                        // No handle found. Check if a handle for this path + a
                                        // trailing slash exists
                                        n = n.children[0]
                                        if n.path == "/" &amp;&amp; n.route != nil </span><span class="cov8" title="1">{
                                                return append(ciPath, '/'), true
                                        }</span>
                                }
                                <span class="cov8" title="1">return ciPath, false</span>

                        case catchAll:<span class="cov8" title="1">
                                return append(ciPath, path...), true</span>

                        default:<span class="cov8" title="1">
                                panic("invalid node type")</span>
                        }
                } else<span class="cov8" title="1"> {
                        // We should have reached the node containing the handle.
                        // Check if this node has a handle registered.
                        if n.route != nil </span><span class="cov8" title="1">{
                                return ciPath, true
                        }</span>

                        // No handle found.
                        // Try to fix the path by adding a trailing slash
                        <span class="cov8" title="1">if fixTrailingSlash </span><span class="cov8" title="1">{
                                for i := 0; i &lt; len(n.indices); i++ </span><span class="cov8" title="1">{
                                        if n.indices[i] == '/' </span><span class="cov8" title="1">{
                                                n = n.children[i]
                                                if (len(n.path) == 1 &amp;&amp; n.route != nil) ||
                                                        (n.nodeType == catchAll &amp;&amp; n.children[0].route != nil) </span><span class="cov8" title="1">{
                                                        return append(ciPath, '/'), true
                                                }</span>
                                                <span class="cov8" title="1">return ciPath, false</span>
                                        }
                                }
                        }
                        <span class="cov8" title="1">return ciPath, false</span>
                }
        }

        // Nothing found.
        // Try to fix the path by adding / removing a trailing slash
        <span class="cov8" title="1">if fixTrailingSlash </span><span class="cov8" title="1">{
                if path == "/" </span><span class="cov8" title="1">{
                        return ciPath, true
                }</span>
                <span class="cov8" title="1">if len(loPath)+1 == len(loNPath) &amp;&amp; loNPath[len(loPath)] == '/' &amp;&amp;
                        loPath[1:] == loNPath[1:len(loPath)] &amp;&amp; n.route != nil </span><span class="cov8" title="1">{
                        return append(ciPath, n.path...), true
                }</span>
        }
        <span class="cov8" title="1">return ciPath, false</span>
}

// CleanPath is the URL version of path.Clean, it returns a canonical URL path
// for p, eliminating . and .. elements.
//
// The following rules are applied iteratively until no further processing can
// be done:
//        1. Replace multiple slashes with a single slash.
//        2. Eliminate each . path name element (the current directory).
//        3. Eliminate each inner .. path name element (the parent directory)
//           along with the non-.. element that precedes it.
//        4. Eliminate .. elements that begin a rooted path:
//           that is, replace "/.." by "/" at the beginning of a path.
//
// If the result of this process is an empty string, "/" is returned
func CleanPath(p string) string <span class="cov0" title="0">{
        // Turn empty string into "/"
        if p == "" </span><span class="cov0" title="0">{
                return "/"
        }</span>

        <span class="cov0" title="0">n := len(p)
        var buf []byte

        // Invariants:
        //      reading from path; r is index of next byte to process.
        //      writing to buf; w is index of next byte to write.

        // path must start with '/'
        r := 1
        w := 1

        if p[0] != '/' </span><span class="cov0" title="0">{
                r = 0
                buf = make([]byte, n+1)
                buf[0] = '/'
        }</span>

        <span class="cov0" title="0">trailing := n &gt; 2 &amp;&amp; p[n-1] == '/'

        // A bit more clunky without a 'lazybuf' like the path package, but the loop
        // gets completely inlined (bufApp). So in contrast to the path package this
        // loop has no expensive function calls (except 1x make)

        for r &lt; n </span><span class="cov0" title="0">{
                switch </span>{
                case p[r] == '/':<span class="cov0" title="0">
                        // empty path element, trailing slash is added after the end
                        r++</span>

                case p[r] == '.' &amp;&amp; r+1 == n:<span class="cov0" title="0">
                        trailing = true
                        r++</span>

                case p[r] == '.' &amp;&amp; p[r+1] == '/':<span class="cov0" title="0">
                        // . element
                        r++</span>

                case p[r] == '.' &amp;&amp; p[r+1] == '.' &amp;&amp; (r+2 == n || p[r+2] == '/'):<span class="cov0" title="0">
                        // .. element: remove to last /
                        r += 2

                        if w &gt; 1 </span><span class="cov0" title="0">{
                                // can backtrack
                                w--

                                if buf == nil </span><span class="cov0" title="0">{
                                        for w &gt; 1 &amp;&amp; p[w] != '/' </span><span class="cov0" title="0">{
                                                w--
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        for w &gt; 1 &amp;&amp; buf[w] != '/' </span><span class="cov0" title="0">{
                                                w--
                                        }</span>
                                }
                        }

                default:<span class="cov0" title="0">
                        // real path element.
                        // add slash if needed
                        if w &gt; 1 </span><span class="cov0" title="0">{
                                bufApp(&amp;buf, p, w, '/')
                                w++
                        }</span>

                        // copy element
                        <span class="cov0" title="0">for r &lt; n &amp;&amp; p[r] != '/' </span><span class="cov0" title="0">{
                                bufApp(&amp;buf, p, w, p[r])
                                w++
                                r++
                        }</span>
                }
        }

        // re-append trailing slash
        <span class="cov0" title="0">if trailing &amp;&amp; w &gt; 1 </span><span class="cov0" title="0">{
                bufApp(&amp;buf, p, w, '/')
                w++
        }</span>

        <span class="cov0" title="0">if buf == nil </span><span class="cov0" title="0">{
                return p[:w]
        }</span>
        <span class="cov0" title="0">return string(buf[:w])</span>
}

// internal helper to lazily create a buffer if necessary
func bufApp(buf *[]byte, s string, w int, c byte) <span class="cov0" title="0">{
        if *buf == nil </span><span class="cov0" title="0">{
                if s[w] == c </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">*buf = make([]byte, len(s))
                copy(*buf, s[:w])</span>
        }
        <span class="cov0" title="0">(*buf)[w] = c</span>
}

func countParams(path string) uint8 <span class="cov8" title="1">{
        var n uint
        for i := 0; i &lt; len(path); i++ </span><span class="cov8" title="1">{
                if path[i] != ':' &amp;&amp; path[i] != '*' </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">n++</span>
        }
        <span class="cov8" title="1">if n &gt;= 255 </span><span class="cov8" title="1">{
                return 255
        }</span>
        <span class="cov8" title="1">return uint8(n)</span>
}

func min(a, b int) int <span class="cov8" title="1">{
        if a &lt;= b </span><span class="cov8" title="1">{
                return a
        }</span>
        <span class="cov8" title="1">return b</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package web

import (
        "crypto/hmac"
        cryptoRand "crypto/rand"
        "crypto/sha512"
        "encoding/base64"
        "encoding/json"
        "encoding/xml"
        "io"
        "net"
        "net/http"
        "net/url"
        "strconv"
        "strings"
        "time"

        "github.com/blend/go-sdk/exception"
        "github.com/blend/go-sdk/util"
)

// MustParseURL parses a url and panics if there is an error.
func MustParseURL(rawURL string) *url.URL <span class="cov8" title="1">{
        u, err := url.Parse(rawURL)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">return u</span>
}

// NestMiddleware reads the middleware variadic args and organizes the calls recursively in the order they appear.
func NestMiddleware(action Action, middleware ...Middleware) Action <span class="cov8" title="1">{
        if len(middleware) == 0 </span><span class="cov0" title="0">{
                return action
        }</span>

        <span class="cov8" title="1">var nest = func(a, b Middleware) Middleware </span><span class="cov8" title="1">{
                if b == nil </span><span class="cov8" title="1">{
                        return a
                }</span>
                <span class="cov8" title="1">return func(action Action) Action </span><span class="cov8" title="1">{
                        return a(b(action))
                }</span>
        }

        <span class="cov8" title="1">var metaAction Middleware
        for _, step := range middleware </span><span class="cov8" title="1">{
                metaAction = nest(step, metaAction)
        }</span>
        <span class="cov8" title="1">return metaAction(action)</span>
}

// WriteNoContent writes http.StatusNoContent for a request.
func WriteNoContent(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.WriteHeader(http.StatusNoContent)
        w.Write([]byte{})
        return nil
}</span>

// WriteRawContent writes raw content for the request.
func WriteRawContent(w http.ResponseWriter, statusCode int, content []byte) error <span class="cov0" title="0">{
        w.WriteHeader(statusCode)
        _, err := w.Write(content)
        return exception.Wrap(err)
}</span>

// WriteJSON marshalls an object to json.
func WriteJSON(w http.ResponseWriter, r *http.Request, statusCode int, response interface{}) error <span class="cov8" title="1">{
        w.Header().Set(HeaderContentType, ContentTypeApplicationJSON)
        w.WriteHeader(statusCode)
        return exception.Wrap(json.NewEncoder(w).Encode(response))
}</span>

// WriteXML marshalls an object to json.
func WriteXML(w http.ResponseWriter, r *http.Request, statusCode int, response interface{}) error <span class="cov0" title="0">{
        w.Header().Set(HeaderContentType, ContentTypeXML)
        w.WriteHeader(statusCode)
        return exception.Wrap(xml.NewEncoder(w).Encode(response))
}</span>

// DeserializeReaderAsJSON deserializes a post body as json to a given object.
func DeserializeReaderAsJSON(object interface{}, body io.ReadCloser) error <span class="cov0" title="0">{
        defer body.Close()
        return exception.Wrap(json.NewDecoder(body).Decode(object))
}</span>

// LocalIP returns the local server ip.
func LocalIP() string <span class="cov0" title="0">{
        addrs, err := net.InterfaceAddrs()
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">for _, address := range addrs </span><span class="cov0" title="0">{
                // check the address type and if it is not a loopback the display it
                if ipnet, ok := address.(*net.IPNet); ok &amp;&amp; !ipnet.IP.IsLoopback() </span><span class="cov0" title="0">{
                        if ipnet.IP.To4() != nil </span><span class="cov0" title="0">{
                                return ipnet.IP.String()
                        }</span>
                }
        }
        <span class="cov0" title="0">return ""</span>
}

// NewSessionID returns a new session id.
// It is not a uuid; session ids are generated using a secure random source.
// SessionIDs are generally 64 bytes.
func NewSessionID() string <span class="cov8" title="1">{
        return util.String.MustSecureRandom(32)
}</span>

// SignSessionID returns a new secure session id.
func SignSessionID(sessionID string, key []byte) ([]byte, error) <span class="cov8" title="1">{
        mac := hmac.New(sha512.New, key)
        _, err := mac.Write([]byte(sessionID))
        if err != nil </span><span class="cov0" title="0">{
                return nil, exception.Wrap(err)
        }</span>
        <span class="cov8" title="1">return mac.Sum(nil), nil</span>
}

// MustSignSessionID signs a session id and panics if there is an issue.
func MustSignSessionID(sessionID string, key []byte) []byte <span class="cov8" title="1">{
        signed, err := SignSessionID(sessionID, key)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">return signed</span>
}

// EncodeSignSessionID returns a new secure session id base64 encoded..
func EncodeSignSessionID(sessionID string, key []byte) (string, error) <span class="cov8" title="1">{
        signed, err := SignSessionID(sessionID, key)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return Base64Encode(signed), nil</span>
}

// MustEncodeSignSessionID returns a signed sessionID as base64 encoded.
// It panics if there is an error.
func MustEncodeSignSessionID(sessionID string, key []byte) string <span class="cov8" title="1">{
        return Base64Encode(MustSignSessionID(sessionID, key))
}</span>

// Base64Decode decodes a base64 string.
func Base64Decode(raw string) ([]byte, error) <span class="cov8" title="1">{
        return base64.URLEncoding.DecodeString(raw)
}</span>

// Base64Encode base64 encodes data.
func Base64Encode(raw []byte) string <span class="cov8" title="1">{
        return base64.URLEncoding.EncodeToString(raw)
}</span>

// GenerateCryptoKey generates a cryptographic key.
func GenerateCryptoKey(keySize int) []byte <span class="cov8" title="1">{
        key := make([]byte, keySize)
        io.ReadFull(cryptoRand.Reader, key)
        return key
}</span>

// GenerateSHA512Key generates a crypto key for SHA512 hashing.
func GenerateSHA512Key() []byte <span class="cov8" title="1">{
        return GenerateCryptoKey(64)
}</span>

// PortFromBindAddr returns a port number as an integer from a bind addr.
func PortFromBindAddr(bindAddr string) int32 <span class="cov8" title="1">{
        if len(bindAddr) == 0 </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">parts := strings.SplitN(bindAddr, ":", 2)
        if len(parts) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">if len(parts) &lt; 2 </span><span class="cov8" title="1">{
                return ParseInt32(parts[0])
        }</span>
        <span class="cov8" title="1">return ParseInt32(parts[1])</span>
}

// ParseInt32 parses an int32.
func ParseInt32(v string) int32 <span class="cov8" title="1">{
        parsed, _ := strconv.Atoi(v)
        return int32(parsed)
}</span>

// NewMockRequest creates a mock request.
func NewMockRequest(method, path string) *http.Request <span class="cov8" title="1">{
        return &amp;http.Request{
                Method:     method,
                Proto:      "http",
                ProtoMajor: 1,
                ProtoMinor: 1,
                Host:       "localhost",
                URL: &amp;url.URL{
                        Scheme:  "http",
                        Host:    "localhost",
                        Path:    path,
                        RawPath: path,
                },
        }
}</span>

// NewBasicCookie returns a new name + value pair cookie.
func NewBasicCookie(name, value string) *http.Cookie <span class="cov8" title="1">{
        return &amp;http.Cookie{Name: name, Value: value}
}</span>

// ReadSetCookieByName returns a set cookie by name.
func ReadSetCookieByName(h http.Header, name string) *http.Cookie <span class="cov8" title="1">{
        cookies := ReadSetCookies(h)
        for _, cookie := range cookies </span><span class="cov8" title="1">{
                if cookie != nil &amp;&amp; cookie.Name == name </span><span class="cov8" title="1">{
                        return cookie
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// ReadSetCookies parses all "Set-Cookie" values from
// the header h and returns the successfully parsed Cookies.
func ReadSetCookies(h http.Header) []*http.Cookie <span class="cov8" title="1">{
        cookieCount := len(h["Set-Cookie"])
        if cookieCount == 0 </span><span class="cov0" title="0">{
                return []*http.Cookie{}
        }</span>
        <span class="cov8" title="1">cookies := make([]*http.Cookie, 0, cookieCount)
        for _, line := range h["Set-Cookie"] </span><span class="cov8" title="1">{
                parts := strings.Split(strings.TrimSpace(line), ";")
                if len(parts) == 1 &amp;&amp; parts[0] == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">parts[0] = strings.TrimSpace(parts[0])
                j := strings.Index(parts[0], "=")
                if j &lt; 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">name, value := parts[0][:j], parts[0][j+1:]
                if !isCookieNameValid(name) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">value, ok := parseCookieValue(value, true)
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">c := &amp;http.Cookie{
                        Name:  name,
                        Value: value,
                        Raw:   line,
                }
                for i := 1; i &lt; len(parts); i++ </span><span class="cov8" title="1">{
                        parts[i] = strings.TrimSpace(parts[i])
                        if len(parts[i]) == 0 </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov8" title="1">attr, val := parts[i], ""
                        if j := strings.Index(attr, "="); j &gt;= 0 </span><span class="cov8" title="1">{
                                attr, val = attr[:j], attr[j+1:]
                        }</span>
                        <span class="cov8" title="1">lowerAttr := strings.ToLower(attr)
                        val, ok = parseCookieValue(val, false)
                        if !ok </span><span class="cov0" title="0">{
                                c.Unparsed = append(c.Unparsed, parts[i])
                                continue</span>
                        }
                        <span class="cov8" title="1">switch lowerAttr </span>{
                        case "secure":<span class="cov0" title="0">
                                c.Secure = true
                                continue</span>
                        case "httponly":<span class="cov8" title="1">
                                c.HttpOnly = true
                                continue</span>
                        case "domain":<span class="cov0" title="0">
                                c.Domain = val
                                continue</span>
                        case "max-age":<span class="cov0" title="0">
                                secs, err := strconv.Atoi(val)
                                if err != nil || secs != 0 &amp;&amp; val[0] == '0' </span><span class="cov0" title="0">{
                                        break</span>
                                }
                                <span class="cov0" title="0">if secs &lt;= 0 </span><span class="cov0" title="0">{
                                        secs = -1
                                }</span>
                                <span class="cov0" title="0">c.MaxAge = secs
                                continue</span>
                        case "expires":<span class="cov8" title="1">
                                c.RawExpires = val
                                exptime, err := time.Parse(time.RFC1123, val)
                                if err != nil </span><span class="cov0" title="0">{
                                        exptime, err = time.Parse("Mon, 02-Jan-2006 15:04:05 MST", val)
                                        if err != nil </span><span class="cov0" title="0">{
                                                c.Expires = time.Time{}
                                                break</span>
                                        }
                                }
                                <span class="cov8" title="1">c.Expires = exptime.UTC()
                                continue</span>
                        case "path":<span class="cov8" title="1">
                                c.Path = val
                                continue</span>
                        }
                        <span class="cov0" title="0">c.Unparsed = append(c.Unparsed, parts[i])</span>
                }
                <span class="cov8" title="1">cookies = append(cookies, c)</span>
        }
        <span class="cov8" title="1">return cookies</span>
}

func parseCookieValue(raw string, allowDoubleQuote bool) (string, bool) <span class="cov8" title="1">{
        // Strip the quotes, if present.
        if allowDoubleQuote &amp;&amp; len(raw) &gt; 1 &amp;&amp; raw[0] == '"' &amp;&amp; raw[len(raw)-1] == '"' </span><span class="cov0" title="0">{
                raw = raw[1 : len(raw)-1]
        }</span>
        <span class="cov8" title="1">for i := 0; i &lt; len(raw); i++ </span><span class="cov8" title="1">{
                if !validCookieValueByte(raw[i]) </span><span class="cov0" title="0">{
                        return "", false
                }</span>
        }
        <span class="cov8" title="1">return raw, true</span>
}

func validCookiePathByte(b byte) bool <span class="cov0" title="0">{
        return 0x20 &lt;= b &amp;&amp; b &lt; 0x7f &amp;&amp; b != ';'
}</span>

func validCookieValueByte(b byte) bool <span class="cov8" title="1">{
        return 0x20 &lt;= b &amp;&amp; b &lt; 0x7f &amp;&amp; b != '"' &amp;&amp; b != ';' &amp;&amp; b != '\\'
}</span>

func isCookieNameValid(raw string) bool <span class="cov8" title="1">{
        if raw == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return strings.IndexFunc(raw, isNotToken) &lt; 0</span>
}

var isTokenTable = [127]bool{
        '!':  true,
        '#':  true,
        '$':  true,
        '%':  true,
        '&amp;':  true,
        '\'': true,
        '*':  true,
        '+':  true,
        '-':  true,
        '.':  true,
        '0':  true,
        '1':  true,
        '2':  true,
        '3':  true,
        '4':  true,
        '5':  true,
        '6':  true,
        '7':  true,
        '8':  true,
        '9':  true,
        'A':  true,
        'B':  true,
        'C':  true,
        'D':  true,
        'E':  true,
        'F':  true,
        'G':  true,
        'H':  true,
        'I':  true,
        'J':  true,
        'K':  true,
        'L':  true,
        'M':  true,
        'N':  true,
        'O':  true,
        'P':  true,
        'Q':  true,
        'R':  true,
        'S':  true,
        'T':  true,
        'U':  true,
        'W':  true,
        'V':  true,
        'X':  true,
        'Y':  true,
        'Z':  true,
        '^':  true,
        '_':  true,
        '`':  true,
        'a':  true,
        'b':  true,
        'c':  true,
        'd':  true,
        'e':  true,
        'f':  true,
        'g':  true,
        'h':  true,
        'i':  true,
        'j':  true,
        'k':  true,
        'l':  true,
        'm':  true,
        'n':  true,
        'o':  true,
        'p':  true,
        'q':  true,
        'r':  true,
        's':  true,
        't':  true,
        'u':  true,
        'v':  true,
        'w':  true,
        'x':  true,
        'y':  true,
        'z':  true,
        '|':  true,
        '~':  true,
}

func isToken(r rune) bool <span class="cov8" title="1">{
        i := int(r)
        return i &lt; len(isTokenTable) &amp;&amp; isTokenTable[i]
}</span>

func isNotToken(r rune) bool <span class="cov8" title="1">{
        return !isToken(r)
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">package web

import (
        "bytes"
        "encoding/json"
        "fmt"
        "html/template"
        "strings"
        "sync"
        "time"

        "github.com/blend/go-sdk/exception"
)

// NewViewCache returns a new view cache.
func NewViewCache() *ViewCache <span class="cov8" title="1">{
        return &amp;ViewCache{
                viewFuncMap: viewUtils(),
                viewCache:   template.New(""),
                cached:      true,
        }
}</span>

// NewViewCacheFromConfig returns a new view cache from a config.
func NewViewCacheFromConfig(cfg *ViewCacheConfig) *ViewCache <span class="cov8" title="1">{
        return &amp;ViewCache{
                viewFuncMap: viewUtils(),
                viewCache:   template.New(""),
                viewPaths:   cfg.GetPaths(),
                cached:      cfg.GetCached(),
        }
}</span>

// NewViewCacheWithTemplates creates a new view cache wrapping the templates.
func NewViewCacheWithTemplates(templates *template.Template) *ViewCache <span class="cov0" title="0">{
        return &amp;ViewCache{
                viewFuncMap: viewUtils(),
                viewCache:   templates,
                cached:      true,
        }
}</span>

// ViewCache is the cached views used in view results.
type ViewCache struct {
        viewFuncMap  template.FuncMap
        viewPaths    []string
        viewLiterals []string
        viewCache    *template.Template
        cached       bool

        initializedLock sync.Mutex
        initialized     bool
}

// Initialized returns if the viewcache is initialized.
func (vc *ViewCache) Initialized() bool <span class="cov0" title="0">{
        return vc.initialized
}</span>

// SetCached sets if we should cache views once they're compiled, or always read them from disk.
// Cached == True, use in memory storage for views
// Cached == False, read the file from disk every time we want to render the view.
func (vc *ViewCache) SetCached(cached bool) <span class="cov0" title="0">{
        if vc == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">vc.cached = cached</span>
}

// Cached indicates if the cache is enabled, or if we skip parsing views each load.
// Cached == True, use in memory storage for views
// Cached == False, read the file from disk every time we want to render the view.
func (vc *ViewCache) Cached() bool <span class="cov8" title="1">{
        if vc == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return vc.cached</span>
}

// Initialize caches templates by path.
func (vc *ViewCache) Initialize() error <span class="cov8" title="1">{
        if !vc.initialized </span><span class="cov8" title="1">{
                vc.initializedLock.Lock()
                defer vc.initializedLock.Unlock()

                if !vc.initialized </span><span class="cov8" title="1">{
                        err := vc.initialize()
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        <span class="cov8" title="1">vc.initialized = true</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

func (vc *ViewCache) initialize() error <span class="cov8" title="1">{
        if len(vc.viewPaths) == 0 &amp;&amp; len(vc.viewLiterals) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">views, err := vc.Parse()
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">vc.viewCache = views
        return nil</span>
}

// Parse parses the view tree.
func (vc *ViewCache) Parse() (views *template.Template, err error) <span class="cov8" title="1">{
        views = template.New("").Funcs(vc.viewFuncMap)
        if len(vc.viewPaths) &gt; 0 </span><span class="cov8" title="1">{
                views, err = views.ParseFiles(vc.viewPaths...)
                if err != nil </span><span class="cov0" title="0">{
                        err = exception.Wrap(err)
                        return
                }</span>
        }

        <span class="cov8" title="1">if len(vc.viewLiterals) &gt; 0 </span><span class="cov8" title="1">{
                for _, viewLiteral := range vc.viewLiterals </span><span class="cov8" title="1">{
                        views, err = views.Parse(viewLiteral)
                        if err != nil </span><span class="cov8" title="1">{
                                err = exception.Wrap(err)
                                return
                        }</span>
                }
        }
        <span class="cov8" title="1">return</span>
}

// AddPaths adds paths to the view collection.
func (vc *ViewCache) AddPaths(paths ...string) <span class="cov8" title="1">{
        if vc == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">vc.viewPaths = append(vc.viewPaths, paths...)</span>
}

// AddLiterals adds view literal strings to the view collection.
func (vc *ViewCache) AddLiterals(views ...string) <span class="cov8" title="1">{
        if vc == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">vc.viewLiterals = append(vc.viewLiterals, views...)</span>
}

// SetPaths sets the view paths outright.
func (vc *ViewCache) SetPaths(paths ...string) <span class="cov0" title="0">{
        if vc == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">vc.viewPaths = paths</span>
}

// SetLiterals sets the raw views outright.
func (vc *ViewCache) SetLiterals(viewLiterals ...string) <span class="cov0" title="0">{
        if vc == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">vc.viewLiterals = viewLiterals</span>
}

// Paths returns the view paths.
func (vc *ViewCache) Paths() []string <span class="cov0" title="0">{
        if vc == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return vc.viewPaths</span>
}

// FuncMap returns the global view func map.
func (vc *ViewCache) FuncMap() template.FuncMap <span class="cov0" title="0">{
        if vc == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return vc.viewFuncMap</span>
}

// Templates gets the view cache for the app.
func (vc *ViewCache) Templates() *template.Template <span class="cov8" title="1">{
        if vc == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return vc.viewCache</span>
}

// SetTemplates sets the view cache for the app.
func (vc *ViewCache) SetTemplates(viewCache *template.Template) <span class="cov8" title="1">{
        if vc == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">vc.viewCache = viewCache</span>
}

func viewUtils() template.FuncMap <span class="cov8" title="1">{
        return template.FuncMap{
                "short": func(t time.Time) string </span><span class="cov0" title="0">{
                        return t.Format("1/02/2006 3:04:05 PM")
                }</span>,
                "shortDate": func(t time.Time) string <span class="cov0" title="0">{
                        return t.Format("1/02/2006")
                }</span>,
                "medium": func(t time.Time) string <span class="cov0" title="0">{
                        return t.Format("Jan 02, 2006 3:04:05 PM")
                }</span>,
                "kitchen": func(t time.Time) string <span class="cov0" title="0">{
                        return t.Format(time.Kitchen)
                }</span>,
                "monthDate": func(t time.Time) string <span class="cov0" title="0">{
                        return t.Format("1/2")
                }</span>,
                "money": func(d float64) string <span class="cov0" title="0">{
                        return fmt.Sprintf("$%0.2f", d)
                }</span>,
                "duration": func(d time.Duration) string <span class="cov0" title="0">{
                        if d &gt; time.Hour </span><span class="cov0" title="0">{
                                return fmt.Sprintf("%0.2fh", float64(d)/float64(time.Hour))
                        }</span>
                        <span class="cov0" title="0">if d &gt; time.Minute </span><span class="cov0" title="0">{
                                return fmt.Sprintf("%0.2fm", float64(d)/float64(time.Minute))
                        }</span>
                        <span class="cov0" title="0">if d &gt; time.Second </span><span class="cov0" title="0">{
                                return fmt.Sprintf("%0.2fs", float64(d)/float64(time.Second))
                        }</span>
                        <span class="cov0" title="0">if d &gt; time.Millisecond </span><span class="cov0" title="0">{
                                return fmt.Sprintf("%0.2fms", float64(d)/float64(time.Millisecond))
                        }</span>
                        <span class="cov0" title="0">if d &gt; time.Microsecond </span><span class="cov0" title="0">{
                                return fmt.Sprintf("%0.2fs", float64(d)/float64(time.Microsecond))
                        }</span>
                        <span class="cov0" title="0">return fmt.Sprintf("%dns", d)</span>
                },
                "pct": func(v float64) string <span class="cov0" title="0">{
                        return fmt.Sprintf("%0.2f%%", v*100)
                }</span>,
                "csv": func(items []string) string <span class="cov0" title="0">{
                        return strings.Join(items, ", ")
                }</span>,
                "json": func(v interface{}) (string, error) <span class="cov0" title="0">{
                        contents, err := json.Marshal(v)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>
                        <span class="cov0" title="0">return string(contents), nil</span>
                },
                "jsonPretty": func(v interface{}) (string, error) <span class="cov0" title="0">{
                        buf := bytes.NewBuffer(nil)
                        encoder := json.NewEncoder(buf)
                        encoder.SetIndent("", "\t")
                        err := encoder.Encode(v)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>
                        <span class="cov0" title="0">return buf.String(), nil</span>
                },
        }
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package web

import "github.com/blend/go-sdk/util"

// ViewCacheConfig is a config for the view cache.
type ViewCacheConfig struct {
        Cached *bool    `json:"cached" yaml:"cached" env:"VIEW_CACHE_ENABLED"`
        Paths  []string `json:"paths" yaml:"paths" env:"VIEW_CACHE_PATHS,csv"`
}

// GetCached returns if the viewcache should store templates in memory or read from disk.
func (vcc ViewCacheConfig) GetCached(defaults ...bool) bool <span class="cov8" title="1">{
        return util.Coalesce.Bool(vcc.Cached, true, defaults...)
}</span>

// GetPaths returns default view paths.
func (vcc ViewCacheConfig) GetPaths(defaults ...[]string) []string <span class="cov8" title="1">{
        return util.Coalesce.Strings(vcc.Paths, nil, defaults...)
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">package web

import (
        "github.com/blend/go-sdk/env"
        "github.com/blend/go-sdk/uuid"
)

// ViewModel is a wrapping viewmodel.
type ViewModel struct {
        Ctx       *Ctx
        ViewModel interface{}
}

// HasEnv returns if an env var is set.
func (vm *ViewModel) HasEnv(key string) bool <span class="cov0" title="0">{
        return env.Env().Has(key)
}</span>

// Env returns a value from the environment.
func (vm *ViewModel) Env(key string, defaults ...string) string <span class="cov0" title="0">{
        return env.Env().String(key, defaults...)
}</span>

// UUIDv4 returns a uuidv4 as a string.
func (vm *ViewModel) UUIDv4() string <span class="cov0" title="0">{
        return uuid.V4().String()
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">package web

import (
        "bytes"
        "html/template"

        "github.com/blend/go-sdk/exception"
)

// ViewResult is a result that renders a view.
type ViewResult struct {
        StatusCode int
        ViewModel  interface{}
        Template   *template.Template
        Provider   *ViewResultProvider
}

// Render renders the result to the given response writer.
func (vr *ViewResult) Render(ctx *Ctx) (err error) <span class="cov8" title="1">{
        if vr.Template == nil </span><span class="cov0" title="0">{
                err = exception.New(ErrUnsetViewTemplate)
                return
        }</span>
        <span class="cov8" title="1">ctx.Response().Header().Set(HeaderContentType, ContentTypeHTML)
        buffer := bytes.NewBuffer([]byte{})
        err = vr.Template.Execute(buffer, &amp;ViewModel{
                Ctx:       ctx,
                ViewModel: vr.ViewModel,
        })
        if err != nil </span><span class="cov8" title="1">{
                if vr.Provider != nil </span><span class="cov0" title="0">{
                        err = vr.Provider.InternalError(err).Render(ctx)
                        return
                }</span>
                <span class="cov8" title="1">err = exception.Wrap(err)
                return</span>
        }

        <span class="cov8" title="1">ctx.Response().WriteHeader(vr.StatusCode)
        _, err = ctx.Response().Write(buffer.Bytes())
        if err != nil &amp;&amp; ctx != nil &amp;&amp; ctx.Logger() != nil </span><span class="cov0" title="0">{
                ctx.Logger().Error(err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package web

import (
        "html/template"
        "net/http"

        "github.com/blend/go-sdk/exception"
        "github.com/blend/go-sdk/logger"
)

const (
        // DefaultTemplateNameBadRequest is the default template name for bad request view results.
        DefaultTemplateNameBadRequest = "bad_request"

        // DefaultTemplateNameInternalError is the default template name for internal server error view results.
        DefaultTemplateNameInternalError = "error"

        // DefaultTemplateNameNotFound is the default template name for not found error view results.
        DefaultTemplateNameNotFound = "not_found"

        // DefaultTemplateNameNotAuthorized is the default template name for not authorized error view results.
        DefaultTemplateNameNotAuthorized = "not_authorized"

        // DefaultTemplateBadRequest is a basic view.
        DefaultTemplateBadRequest = `&lt;html&gt;&lt;head&gt;&lt;style&gt;body { font-family: sans-serif; text-align: center; }&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h4&gt;Bad Request&lt;/h4&gt;&lt;/body&gt;&lt;pre&gt;{{ .ViewModel }}&lt;/pre&gt;&lt;/html&gt;`

        // DefaultTemplateInternalError is a basic view.
        DefaultTemplateInternalError = `&lt;html&gt;&lt;head&gt;&lt;style&gt;body { font-family: sans-serif; text-align: center; }&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h4&gt;Internal Error&lt;/h4&gt;&lt;pre&gt;{{ .ViewModel }}&lt;/body&gt;&lt;/html&gt;`

        // DefaultTemplateNotAuthorized is a basic view.
        DefaultTemplateNotAuthorized = `&lt;html&gt;&lt;head&gt;&lt;style&gt;body { font-family: sans-serif; text-align: center; }&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h4&gt;Not Authorized&lt;/h4&gt;&lt;/body&gt;&lt;/html&gt;`

        // DefaultTemplateNotFound is a basic view.
        DefaultTemplateNotFound = `&lt;html&gt;&lt;head&gt;&lt;style&gt;body { font-family: sans-serif; text-align: center; }&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h4&gt;Not Found&lt;/h4&gt;&lt;/body&gt;&lt;/html&gt;`
)

// NewViewResultProvider creates a new ViewResults object.
func NewViewResultProvider(log *logger.Logger, vc *ViewCache) *ViewResultProvider <span class="cov8" title="1">{
        return &amp;ViewResultProvider{log: log, views: vc}
}</span>

// ViewResultProvider returns results based on views.
type ViewResultProvider struct {
        log                       *logger.Logger
        badRequestTemplateName    string
        internalErrorTemplateName string
        notFoundTemplateName      string
        notAuthorizedTemplateName string
        views                     *ViewCache
}

// WithBadRequestTemplateName sets the bad request template.
func (vr *ViewResultProvider) WithBadRequestTemplateName(templateName string) *ViewResultProvider <span class="cov0" title="0">{
        vr.badRequestTemplateName = templateName
        return vr
}</span>

// BadRequestTemplateName returns the bad request template.
func (vr *ViewResultProvider) BadRequestTemplateName() string <span class="cov8" title="1">{
        if len(vr.badRequestTemplateName) &gt; 0 </span><span class="cov0" title="0">{
                return vr.badRequestTemplateName
        }</span>
        <span class="cov8" title="1">return DefaultTemplateNameBadRequest</span>
}

// WithInternalErrorTemplateName sets the bad request template.
func (vr *ViewResultProvider) WithInternalErrorTemplateName(templateName string) *ViewResultProvider <span class="cov0" title="0">{
        vr.internalErrorTemplateName = templateName
        return vr
}</span>

// InternalErrorTemplateName returns the bad request template.
func (vr *ViewResultProvider) InternalErrorTemplateName() string <span class="cov8" title="1">{
        if len(vr.internalErrorTemplateName) &gt; 0 </span><span class="cov0" title="0">{
                return vr.internalErrorTemplateName
        }</span>
        <span class="cov8" title="1">return DefaultTemplateNameInternalError</span>
}

// WithNotFoundTemplateName sets the not found request template name.
func (vr *ViewResultProvider) WithNotFoundTemplateName(templateName string) *ViewResultProvider <span class="cov0" title="0">{
        vr.notFoundTemplateName = templateName
        return vr
}</span>

// NotFoundTemplateName returns the not found template name.
func (vr *ViewResultProvider) NotFoundTemplateName() string <span class="cov8" title="1">{
        if len(vr.notFoundTemplateName) &gt; 0 </span><span class="cov0" title="0">{
                return vr.notFoundTemplateName
        }</span>
        <span class="cov8" title="1">return DefaultTemplateNameNotFound</span>
}

// WithNotAuthorizedTemplateName sets the bad request template.
func (vr *ViewResultProvider) WithNotAuthorizedTemplateName(templateName string) *ViewResultProvider <span class="cov0" title="0">{
        vr.notAuthorizedTemplateName = templateName
        return vr
}</span>

// NotAuthorizedTemplateName returns the bad request template name.
func (vr *ViewResultProvider) NotAuthorizedTemplateName() string <span class="cov8" title="1">{
        if len(vr.notAuthorizedTemplateName) &gt; 0 </span><span class="cov0" title="0">{
                return vr.notAuthorizedTemplateName
        }</span>
        <span class="cov8" title="1">return DefaultTemplateNameNotAuthorized</span>
}

// BadRequest returns a view result.
func (vr *ViewResultProvider) BadRequest(err error) Result <span class="cov8" title="1">{
        if vr.log != nil </span><span class="cov0" title="0">{
                vr.log.Warning(err)
        }</span>

        <span class="cov8" title="1">initErr := vr.views.Initialize()
        if initErr != nil </span><span class="cov0" title="0">{
                return vr.InternalError(exception.NewFromErr(initErr).WithMessagef("viewname: %s", vr.BadRequestTemplateName()))
        }</span>

        <span class="cov8" title="1">temp := vr.views.Templates().Lookup(vr.BadRequestTemplateName())
        if temp == nil </span><span class="cov8" title="1">{
                temp, _ = template.New("").Parse(DefaultTemplateBadRequest)
        }</span>

        <span class="cov8" title="1">return &amp;ViewResult{
                StatusCode: http.StatusBadRequest,
                ViewModel:  err,
                Template:   temp,
        }</span>
}

// InternalError returns a view result.
func (vr *ViewResultProvider) InternalError(err error) Result <span class="cov8" title="1">{
        if vr.log != nil </span><span class="cov8" title="1">{
                vr.log.Fatal(err)
        }</span>

        <span class="cov8" title="1">initErr := vr.views.Initialize()
        if initErr != nil </span><span class="cov8" title="1">{
                temp, _ := template.New("").Parse(DefaultTemplateInternalError)
                return &amp;ViewResult{
                        StatusCode: http.StatusInternalServerError,
                        ViewModel:  initErr,
                        Template:   temp,
                }
        }</span>

        <span class="cov8" title="1">temp := vr.views.Templates().Lookup(vr.InternalErrorTemplateName())
        if temp == nil </span><span class="cov8" title="1">{
                temp, _ = template.New("").Parse(DefaultTemplateInternalError)
        }</span>

        <span class="cov8" title="1">return &amp;ViewResult{
                StatusCode: http.StatusInternalServerError,
                ViewModel:  err,
                Template:   temp,
        }</span>
}

// NotFound returns a view result.
func (vr *ViewResultProvider) NotFound() Result <span class="cov8" title="1">{
        err := vr.views.Initialize()
        if err != nil </span><span class="cov0" title="0">{
                return vr.InternalError(exception.NewFromErr(err).WithMessagef("viewname: %s", vr.NotFoundTemplateName()))
        }</span>

        <span class="cov8" title="1">temp := vr.views.Templates().Lookup(vr.NotFoundTemplateName())
        if temp == nil </span><span class="cov8" title="1">{
                temp, _ = template.New("").Parse(DefaultTemplateNotFound)
        }</span>

        <span class="cov8" title="1">return &amp;ViewResult{
                StatusCode: http.StatusNotFound,
                Template:   temp,
        }</span>
}

// NotAuthorized returns a view result.
func (vr *ViewResultProvider) NotAuthorized() Result <span class="cov8" title="1">{
        err := vr.views.Initialize()
        if err != nil </span><span class="cov0" title="0">{
                return vr.InternalError(exception.NewFromErr(err).WithMessagef("viewname: %s", vr.NotAuthorizedTemplateName()))
        }</span>

        <span class="cov8" title="1">temp := vr.views.Templates().Lookup(vr.NotAuthorizedTemplateName())
        if temp == nil </span><span class="cov8" title="1">{
                temp, _ = template.New("").Parse(DefaultTemplateNotAuthorized)
        }</span>

        <span class="cov8" title="1">return &amp;ViewResult{
                StatusCode: http.StatusForbidden,
                Template:   temp,
        }</span>
}

// View returns a view result.
func (vr *ViewResultProvider) View(viewName string, viewModel interface{}) Result <span class="cov8" title="1">{
        err := vr.views.Initialize()
        if err != nil </span><span class="cov8" title="1">{
                return vr.InternalError(exception.NewFromErr(err).WithMessagef("viewname: %s", viewName))
        }</span>

        <span class="cov8" title="1">temp := vr.views.Templates().Lookup(viewName)
        if temp == nil </span><span class="cov0" title="0">{
                return vr.InternalError(exception.NewFromErr(ErrUnsetViewTemplate).WithMessagef("viewname: %s", viewName))
        }</span>
        <span class="cov8" title="1">return &amp;ViewResult{
                StatusCode: http.StatusOK,
                ViewModel:  viewModel,
                Provider:   vr,
                Template:   temp,
        }</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package web

// XMLResult is a json result.
type XMLResult struct {
        StatusCode int
        Response   interface{}
}

// Render renders the result
func (ar *XMLResult) Render(ctx *Ctx) error <span class="cov0" title="0">{
        return WriteXML(ctx.Response(), ctx.Request(), ar.StatusCode, ar.Response)
}</span>
</pre>
		
		<pre class="file" id="file44" style="display: none">package web

import (
        "net/http"

        "github.com/blend/go-sdk/logger"
)

// NewXMLResultProvider Creates a new JSONResults object.
func NewXMLResultProvider(log *logger.Logger) *XMLResultProvider <span class="cov0" title="0">{
        return &amp;XMLResultProvider{log: log}
}</span>

// XMLResultProvider are context results for api methods.
type XMLResultProvider struct {
        log *logger.Logger
}

// NotFound returns a service response.
func (xrp *XMLResultProvider) NotFound() Result <span class="cov0" title="0">{
        return &amp;XMLResult{
                StatusCode: http.StatusNotFound,
                Response:   "Not Found",
        }
}</span>

// NotAuthorized returns a service response.
func (xrp *XMLResultProvider) NotAuthorized() Result <span class="cov0" title="0">{
        return &amp;XMLResult{
                StatusCode: http.StatusForbidden,
                Response:   "Not Authorized",
        }
}</span>

// InternalError returns a service response.
func (xrp *XMLResultProvider) InternalError(err error) Result <span class="cov0" title="0">{
        if xrp.log != nil </span><span class="cov0" title="0">{
                xrp.log.Fatal(err)
        }</span>

        <span class="cov0" title="0">return &amp;XMLResult{
                StatusCode: http.StatusInternalServerError,
                Response:   err.Error(),
        }</span>
}

// BadRequest returns a service response.
func (xrp *XMLResultProvider) BadRequest(err error) Result <span class="cov0" title="0">{
        if err != nil </span><span class="cov0" title="0">{
                return &amp;XMLResult{
                        StatusCode: http.StatusBadRequest,
                        Response:   err,
                }
        }</span>
        <span class="cov0" title="0">return &amp;XMLResult{
                StatusCode: http.StatusBadRequest,
                Response:   "Bad Request",
        }</span>
}

// OK returns a service response.
func (xrp *XMLResultProvider) OK() Result <span class="cov0" title="0">{
        return &amp;XMLResult{
                StatusCode: http.StatusOK,
                Response:   "OK!",
        }
}</span>

// Result returns an xml response.
func (xrp *XMLResultProvider) Result(response interface{}) Result <span class="cov0" title="0">{
        return &amp;XMLResult{
                StatusCode: http.StatusOK,
                Response:   response,
        }
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
